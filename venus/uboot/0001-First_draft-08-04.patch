From b3d3671640e086e00087e06b754baa245d3386dd Mon Sep 17 00:00:00 2001
From: Kate Liu <kate.liu@cortina-access.com>
Date: Tue, 4 Aug 2020 01:42:55 +0000
Subject: [PATCH 1/3] First_draft 08/04

Added cortina_nand.c, probe ok, env load failed.

Type:refactoring
Scope:venus
Bug:n/a
---
 arch/arm/dts/ca-venus-engboard.dts  |   20 +-
 drivers/mtd/nand/raw/Kconfig        |   12 +
 drivers/mtd/nand/raw/Makefile       |    1 +
 drivers/mtd/nand/raw/cortina_nand.c | 1383 +++++++++++++++++++++++++++++++++++
 drivers/mtd/nand/raw/cortina_nand.h |  688 +++++++++++++++++
 include/configs/venus.h             |    4 +-
 6 files changed, 2105 insertions(+), 3 deletions(-)
 create mode 100644 drivers/mtd/nand/raw/cortina_nand.c
 create mode 100644 drivers/mtd/nand/raw/cortina_nand.h

diff --git a/arch/arm/dts/ca-venus-engboard.dts b/arch/arm/dts/ca-venus-engboard.dts
index 502c953..433dc20 100644
--- a/arch/arm/dts/ca-venus-engboard.dts
+++ b/arch/arm/dts/ca-venus-engboard.dts
@@ -60,12 +60,28 @@
 		clock-frequency = <400000>;
 	};
 
+	nand: nand-controller@f4324000 {
+		#address-cells = <1>;
+		#size-cells = <0>;
+		compatible = "cortina,ca-nand";
+		reg = <0 0xf4324000 0x3b0>, /* NAND controller */
+		      <0 0xf7001a00 0xb4>, /* DMA_GLOBAL */
+		      <0 0xf7001a00 0x80>; /* DMA channel0 for FLASH */
+		status = "okay";
+		nand-ecc-mode = "hw";
+		nand-ecc-strength = <16>;
+		nand-ecc-step-size = <1024>;    /* Must be 1024 */
+		nand_flash_base_addr = <0xe0000000>;
+	};
+
 	sflash: sflash-controller@f4324000 {
 		#address-cells = <2>;
 		#size-cells = <1>;
 		compatible = "cortina,ca-sflash";
 		reg = <0x0 0xf4324000 0x50>;
 		reg-names = "sflash-regs";
+		status = "disabled";
+
 		flash@0 {
 			compatible = "jedec,spi-nor";
 			spi-rx-bus-width = <1>;
@@ -132,12 +148,12 @@
 		};
 	};
 
-        eth: ethnet@0xf4300000 {
+	eth: ethnet@0xf4300000 {
 	     compatible = "eth_cortina";
 	     reg = <0x0 0xf4320000 0x34>,
 		   <0x0 0xf4329118 0x04>,
 		   <0x0 0xf4304000 0x04>;
-        };
+	};
 };
 
 &vdd_regulator {
diff --git a/drivers/mtd/nand/raw/Kconfig b/drivers/mtd/nand/raw/Kconfig
index 493aff6..8a4531a 100644
--- a/drivers/mtd/nand/raw/Kconfig
+++ b/drivers/mtd/nand/raw/Kconfig
@@ -341,6 +341,18 @@ config NAND_STM32_FMC2
 	  The controller supports a maximum 8k page size and supports
 	  a maximum 8-bit correction error per sector of 512 bytes.
 
+config CORTINA_NAND
+        bool "Support for NAND controller on Cortina-Access SoCs"
+        depends on CORTINA_PLATFORM
+        select SYS_NAND_SELF_INIT
+        select DM_MTD
+        imply CMD_NAND
+        help
+          Enables support for NAND Flash chips on Coartina-Access SoCs platform
+          This controller is found on Presidio/Venus SoCs.
+          The controller supports a maximum 8k page size and supports
+          a maximum 40-bit error correction per sector of 1024 bytes.
+
 comment "Generic NAND options"
 
 config SYS_NAND_BLOCK_SIZE
diff --git a/drivers/mtd/nand/raw/Makefile b/drivers/mtd/nand/raw/Makefile
index 572e9e6..f4991c2 100644
--- a/drivers/mtd/nand/raw/Makefile
+++ b/drivers/mtd/nand/raw/Makefile
@@ -68,6 +68,7 @@ obj-$(CONFIG_NAND_PLAT) += nand_plat.o
 obj-$(CONFIG_NAND_SUNXI) += sunxi_nand.o
 obj-$(CONFIG_NAND_ZYNQ) += zynq_nand.o
 obj-$(CONFIG_NAND_STM32_FMC2) += stm32_fmc2_nand.o
+obj-$(CONFIG_CORTINA_NAND) += cortina_nand.o
 
 else  # minimal SPL drivers
 
diff --git a/drivers/mtd/nand/raw/cortina_nand.c b/drivers/mtd/nand/raw/cortina_nand.c
new file mode 100644
index 0000000..cd5f7d1
--- /dev/null
+++ b/drivers/mtd/nand/raw/cortina_nand.c
@@ -0,0 +-2,1382 @@
+// SPDX-License-Identifier: GPL-2.0+
+/*
+ * Copyright (c) 2020, Cortina Access Inc..
+ */
+
+#include <common.h>
+#include <linux/delay.h>
+#include <linux/bitops.h>
+#include <log.h>
+#include <asm/io.h>
+#include <memalign.h>
+#include <nand.h>
+#include <dm/device_compat.h>
+#include <linux/bug.h>
+#include <linux/delay.h>
+#include <linux/iopoll.h>
+#include <linux/errno.h>
+#include <asm/gpio.h>
+#include <fdtdec.h>
+#include <bouncebuf.h>
+#include <dm.h>
+#include "cortina_nand.h"
+
+DECLARE_GLOBAL_DATA_PTR;
+
+#define SKIPPED_SPARE_BYTES		4
+
+/* ECC bytes to be generated for tag data */
+#define TAG_ECC_BYTES			4
+
+static const struct udevice_id cortina_nand_dt_ids[] = {
+	{
+		.compatible = "cortina,ca-nand",
+	},
+	{ /* sentinel */ }
+};
+
+/* 64 byte oob block info for large page (== 2KB) device
+ *
+ * OOB flash layout BCH16 ECC:
+ *      Bad block marker :1 byte
+ *      Free OOB 6 bytes
+ *      Eerase flag 1 byte
+ *      ECC code: 56 bytes(BCH16 for 2K page)
+ */
+static struct nand_ecclayout eccoob = {
+	.eccbytes = 56,
+	.eccpos = {
+		 8, 9,  10, 11, 12, 13, 14, 15,
+		16, 17, 18, 19, 20, 21, 22, 23,
+		24, 25, 26, 27, 28, 29, 30, 31,
+		32, 33, 34, 35,	36, 37, 38, 39,
+		40, 41, 42, 43, 44, 45, 46, 47,
+		48, 49, 50, 51, 52, 53,	54, 55,
+		56, 57, 58, 59, 60, 61, 62, 63,
+	},
+	.oobavail = 6,
+	.oobfree = {
+			{
+			.offset = 01,
+			.length = 6,
+			},
+	}
+};
+
+enum {
+	ECC_OK,
+	ECC_TAG_ERROR = 1 << 0,
+	ECC_DATA_ERROR = 1 << 1
+};
+
+/* Timing parameters */
+enum {
+	FDT_NAND_MAX_TRP_TREA,
+	FDT_NAND_TWB,
+	FDT_NAND_MAX_TCR_TAR_TRR,
+	FDT_NAND_TWHR,
+	FDT_NAND_MAX_TCS_TCH_TALS_TALH,
+	FDT_NAND_TWH,
+	FDT_NAND_TWP,
+	FDT_NAND_TRH,
+	FDT_NAND_TADL,
+
+	FDT_NAND_TIMING_COUNT
+};
+
+/* Information about an attached NAND chip */
+struct fdt_nand {
+	int enabled;		/* 1 to enable, 0 to disable */
+	s32 width;		/* bit width, must be 8 */
+	u32 timing[FDT_NAND_TIMING_COUNT];
+	u32 nand_ecc_strength;
+};
+
+struct nand_drv {
+	u32 fifo_index;
+	struct nand_ctlr *reg;
+	struct dma_global *dma_glb;
+	struct dma_ssp *dma_nand;
+	struct tx_descriptor_t *tx_desc;
+	struct rx_descriptor_t *rx_desc;
+	struct fdt_nand config;
+	unsigned int flash_base;
+};
+
+struct ca_nand_info {
+	struct udevice *dev;
+	struct nand_drv nand_ctrl;
+	struct nand_chip nand_chip;
+};
+
+/**
+ * Wait for command completion
+ *
+ * @param reg	nand_ctlr structure
+ * @return
+ *	1 - Command completed
+ *	0 - Timeout
+ */
+static int nand_waitfor_cmd_completion(struct nand_ctlr *reg)
+{
+	unsigned int reg_v = 0;
+
+	if (readl_poll_timeout(&reg->flash_flash_access_start, reg_v, \
+			!(reg_v & NFLASH_GO), FLASH_LONG_DELAY)) {
+		pr_err("Nand CMD timeout!\n");
+		return 0;
+	}
+
+	return 1;
+}
+
+/**
+ * block_bad - [DEFAULT] Read bad block marker from the chip
+ * @mtd:        MTD device structure
+ * @ofs:        offset from device start
+ *
+ * Check, if the block is bad.
+ */
+static int block_bad(struct mtd_info *mtd, loff_t ofs)
+{
+#ifdef CONFIG_NAND_HIDE_BAD
+	printf("hide bad!!\n");
+	if (!acc_phy_offset) {
+		return 0;
+	}
+#endif
+
+	int page, res = 0;
+	struct nand_chip *chip = mtd_to_nand(mtd);
+
+	printf("block_bad function start!\n");
+	page = (int)(ofs >> chip->page_shift) & chip->pagemask;
+
+	printf("read_oob  before function start!%p\n", chip->ecc.read_oob);
+//        ca_wand_read_oob_std(mtd, chip, page)
+	chip->ecc.read_oob(mtd, chip, page);
+	printf("read_oob after function start!\n");
+
+	if (chip->oob_poi[chip->badblockpos] != 0xff)
+		return 1;
+
+	return res;
+}
+
+/**
+ * Read one byte from the chip
+ *
+ * @param mtd	MTD device structure
+ * @return	data byte
+ *
+ * Read function for 8bit bus-width
+ */
+static uint8_t read_byte(struct mtd_info *mtd)
+{
+	struct nand_chip *chip = mtd_to_nand(mtd);
+	struct nand_drv *info;
+	u8 ret_v;
+
+	info = (struct nand_drv *)nand_get_controller_data(chip);
+
+	writel(NFLASH_GO | NFLASH_RD, &info->reg->flash_flash_access_start);
+
+	if (!nand_waitfor_cmd_completion(info->reg))
+		printf("%s: Command timeout\n", __func__);
+
+	ret_v = readl(&info->reg->flash_nf_data) >> (8 * info->fifo_index++);
+	info->fifo_index %= 4;
+
+	return (uint8_t)ret_v;
+}
+
+/**
+ * Read len bytes from the chip into a buffer
+ *
+ * @param mtd	MTD device structure
+ * @param buf	buffer to store data to
+ * @param len	number of bytes to read
+ *
+ * Read function for 8bit bus-width
+ */
+static void read_buf(struct mtd_info *mtd, uint8_t *buf, int len)
+{
+#if 0
+	int i, s;
+	unsigned int reg;
+	struct nand_chip *chip = mtd_to_nand(mtd);
+	struct nand_drv *info = (struct nand_drv *)nand_get_controller_data(chip);
+
+	for (i = 0; i < len; i += 4) {
+		s = (len - i) > 4 ? 4 : len - i;
+		writel(CMD_PIO | CMD_RX | CMD_A_VALID | CMD_CE0 |
+			((s - 1) << CMD_TRANS_SIZE_SHIFT) | CMD_GO,
+			&info->reg->command);
+		if (!nand_waitfor_cmd_completion(info->reg))
+			puts("Command timeout during read_buf\n");
+		reg = readl(&info->reg->resp);
+		memcpy(buf + i, &reg, s);
+	}
+#endif
+}
+
+/**
+ * Check READY pin status to see if it is ready or not
+ *
+ * @param mtd	MTD device structure
+ * @return
+ *	1 - ready
+ *	0 - not ready
+ */
+static int nand_dev_ready(struct mtd_info *mtd)
+{
+	struct nand_chip *chip = mtd_to_nand(mtd);
+	int reg_val;
+	struct nand_drv *info;
+
+	info = (struct nand_drv *)nand_get_controller_data(chip);
+
+	reg_val = readl(&info->reg->flash_status);
+	if (reg_val & NFLASH_READY)
+		return 1;
+	else
+		return 0;
+}
+
+/* Dummy implementation: we don't support multiple chips */
+static void nand_select_chip(struct mtd_info *mtd, int chipnr)
+{
+	switch (chipnr) {
+	case -1:
+	case 0:
+		break;
+
+	default:
+		BUG();
+	}
+}
+
+int init_nand_dma(struct nand_chip *nand)
+{
+	int i;
+	struct nand_drv *info;
+
+	info = (struct nand_drv *)nand_get_controller_data(nand);
+
+	setbits_le32(&info->dma_glb->dma_glb_dma_lso_ctrl, TX_DMA_ENABLE);
+	setbits_le32(&info->dma_glb->dma_glb_dma_ssp_rx_ctrl, TX_DMA_ENABLE | DMA_CHECK_OWNER);
+	setbits_le32(&info->dma_glb->dma_glb_dma_ssp_tx_ctrl, RX_DMA_ENABLE | DMA_CHECK_OWNER);
+
+	info->tx_desc = malloc_cache_aligned((sizeof(struct tx_descriptor_t) * \
+					CA_DMA_DESC_NUM));
+	info->rx_desc = malloc_cache_aligned((sizeof(struct rx_descriptor_t) * \
+					CA_DMA_DESC_NUM));
+
+	if (!info->rx_desc || !info->tx_desc) {
+		printf("Fail to alloc DMA descript!\n");
+		kfree(info->rx_desc);
+		kfree(info->tx_desc);
+		return -ENOMEM;
+	}
+
+	/* set RX DMA base address and depth */
+	clrsetbits_le32(&info->dma_nand->dma_q_rxq_base_depth, \
+				GENMASK(31, 4), (uintptr_t)info->rx_desc);
+	clrsetbits_le32(&info->dma_nand->dma_q_rxq_base_depth, \
+				GENMASK(3, 0), CA_DMA_DEPTH);
+
+	/* set TX DMA base address and depth */
+	clrsetbits_le32(&info->dma_nand->dma_q_txq_base_depth, \
+				GENMASK(31, 4), (uintptr_t)info->tx_desc);
+	clrsetbits_le32(&info->dma_nand->dma_q_txq_base_depth, \
+				GENMASK(3, 0), CA_DMA_DEPTH);
+
+	memset((unsigned char *)info->tx_desc, 0,
+	       (sizeof(struct tx_descriptor_t) * CA_DMA_DESC_NUM));
+	memset((unsigned char *)info->rx_desc, 0,
+	       (sizeof(struct rx_descriptor_t) * CA_DMA_DESC_NUM));
+
+	for (i = 0; i < CA_DMA_DESC_NUM; i++) {
+		/* set owner bit as SW */
+		info->tx_desc[i].own = 1;
+		/* enable Scatter-Gather memory copy */
+		info->tx_desc[i].sgm = 0x1;
+	}
+
+	return 0;
+}
+
+#if 0
+static void check_flash_ctrl_status(struct mtd_info *mtd)
+{
+	unsigned long timeo;
+	u32 status;
+	struct nand_chip *chip = mtd_to_nand(mtd);
+	struct nand_drv *info;
+
+	info = (struct nand_drv *)nand_get_controller_data(chip);
+
+	timeo = jiffies + HZ;
+	do {
+		status = read_flash_ctrl_reg(&info->reg->flash_status);
+		if (!status)
+			return;
+	} while (time_before(jiffies, timeo));
+
+	printk("FLASH_STATUS ERROR: %x\n", status);
+}
+#endif
+/**
+ * Send command to NAND device
+ *
+ * @param mtd		MTD device structure
+ * @param command	the command to be sent
+ * @param column	the column address for this command, -1 if none
+ * @param page_addr	the page address for this command, -1 if none
+ */
+static void ca_nand_command(struct mtd_info *mtd, unsigned int command,
+			    int column, int page_addr)
+{
+	struct nand_chip *chip = mtd_to_nand(mtd);
+	struct nand_drv *info;
+	unsigned int cmd_reg = 0;
+	unsigned int reg_v = 0;
+	int ret;
+
+	info = (struct nand_drv *)nand_get_controller_data(chip);
+	/*
+	 * Write out the command to the device.
+	 *
+	 * Only command NAND_CMD_RESET or NAND_CMD_READID will come
+	 * here before mtd->writesize is initialized.
+	 */
+
+	/* Emulate NAND_CMD_READOOB */
+	if (command == NAND_CMD_READOOB) {
+		printf("command==NAND_CMD_READOOB\n)");
+		assert(mtd->writesize != 0);
+		column += mtd->writesize;
+		command = NAND_CMD_READ0;
+	}
+
+	/* Reset FIFO before issue new command */
+	writel(ECC_RESET_ALL, \
+		&info->reg->flash_nf_ecc_reset);
+	ret = readl_poll_timeout(&info->reg->flash_nf_ecc_reset, reg_v, \
+			!(reg_v & RESET_NFLASH_FIFO), FLASH_SHORT_DELAY);
+	if (ret) {
+			printf("FIFO reset timeout\n");
+			writel(ECC_RESET_ALL, &info->reg->flash_nf_ecc_reset);
+			udelay(10);
+	}
+
+	/* Reset FIFO index
+	 * Next read start from flash_nf_data[0]
+	 */
+	info->fifo_index = 0;
+
+	/*
+	 * Program and erase have their own busy handlers
+	 * status and sequential in needs no delay
+	 */
+	switch (command) {
+	case NAND_CMD_READID:
+		//clrbits_le32(&info->reg->flash_nf_ecc_control, BCH_ENABLE);
+		//printf("flash_nf_ecc_control: %x\n", readl(&info->reg->flash_nf_ecc_control));
+		writel(NAND_CMD_READID, &info->reg->flash_nf_command);
+		writel(column & 0xFF, &info->reg->flash_nf_address_1);
+		writel(column & 0xFF, &info->reg->flash_nf_address_2);
+		/* 1 byte CMD cycle */
+		clrbits_le32(&info->reg->flash_nf_count, GENMASK(1, 0));
+		/* 1 byte CMD cycle */
+		clrbits_le32(&info->reg->flash_nf_count, GENMASK(6, 4));
+		/* Data cycle */
+		clrsetbits_le32(&info->reg->flash_nf_count, GENMASK(21, 8), REG_DATA_COUNT_DATA_8 << 8);
+		/* 0 OOB cycle */
+		setbits_le32(&info->reg->flash_nf_count, GENMASK(31, 22));
+		/* clear FLASH_NF_ACCESS */
+		clrbits_le32(&info->reg->flash_nf_access, 0xffffffff);
+
+		break;
+	case NAND_CMD_PARAM:
+		writel(NAND_CMD_PARAM, &info->reg->flash_nf_command);
+		writel(column & 0xFF, &info->reg->flash_nf_address_1);
+		/* 1 byte CMD cycle */
+		clrbits_le32(&info->reg->flash_nf_count, GENMASK(1, 0));
+		/* 1 byte ADDR cycle */
+		clrbits_le32(&info->reg->flash_nf_count, GENMASK(6, 4));
+		/* Data cycle */
+		clrsetbits_le32(&info->reg->flash_nf_count, GENMASK(21, 8), 4095 << 8);
+		/* 0 OOB cycle */
+		setbits_le32(&info->reg->flash_nf_count, GENMASK(31, 22));
+		break;
+	case NAND_CMD_READ0:
+		printf("printf(in NAND_CMD_READ0\n");
+		cmd_reg = NAND_CMD_READ0 | (NAND_CMD_READSTART << 8);
+		writel(cmd_reg, &info->reg->flash_nf_command);
+		/* 2 byte CMD cycle */
+		clrsetbits_le32(&info->reg->flash_nf_count, GENMASK(1, 0), REG_CMD_COUNT_2TOGO);
+		/* 5 byte CMD cycle */
+		clrsetbits_le32(&info->reg->flash_nf_count, GENMASK(6, 4), REG_ADDR_COUNT_5);
+		/* Data cycle */
+		clrsetbits_le32(&info->reg->flash_nf_count, GENMASK(21, 8), \
+						(mtd->writesize - 1) << 8);
+		/* OOB cycle */
+		clrsetbits_le32(&info->reg->flash_nf_count, GENMASK(31, 22), \
+						(mtd->oobsize - 1) << 22);
+
+		writel((page_addr << 16) | (column & 0xFFFF),
+		       &info->reg->flash_nf_address_1);
+		writel(page_addr >> 16, &info->reg->flash_nf_address_2);
+		/* FIXME */
+		//ca_nand_dma_read();
+
+		return;
+	case NAND_CMD_SEQIN:
+		writel(NAND_CMD_SEQIN | (NAND_CMD_PAGEPROG << 8), \
+					&info->reg->flash_nf_command);
+		/* 2 byte CMD cycle */
+		clrsetbits_le32(&info->reg->flash_nf_count, GENMASK(1, 0), 1);
+		/* 5 byte CMD cycle */
+		clrsetbits_le32(&info->reg->flash_nf_count, GENMASK(6, 4), 4 << 4);
+		/* Data cycle */
+		clrsetbits_le32(&info->reg->flash_nf_count, GENMASK(21, 8), \
+						(mtd->writesize - 1) << 8);
+		/* OOB cycle */
+		clrsetbits_le32(&info->reg->flash_nf_count, GENMASK(31, 22), \
+						(mtd->oobsize - 1) << 22);
+
+		writel((page_addr << 16) | (column & 0xFFFF),
+		       &info->reg->flash_nf_address_1);
+		writel(page_addr >> 16, &info->reg->flash_nf_address_2);
+		/* FIXME */
+		// ca_nand_dma_write();
+
+		return;
+	case NAND_CMD_PAGEPROG:
+		return;
+	case NAND_CMD_ERASE1:
+		writel(NAND_CMD_ERASE1 | (NAND_CMD_ERASE2 << 8), \
+					&info->reg->flash_nf_command);
+		/* 2 byte CMD cycle */
+		clrsetbits_le32(&info->reg->flash_nf_count, GENMASK(1, 0), 1);
+		/* 3 byte CMD cycle */
+		clrsetbits_le32(&info->reg->flash_nf_count, GENMASK(6, 4), 2 << 4);
+		/* 0 Data cycle */
+		setbits_le32(&info->reg->flash_nf_count, GENMASK(21, 8));
+		/* 0 OOB cycle */
+		setbits_le32(&info->reg->flash_nf_count, GENMASK(31, 22));
+
+		writel(page_addr, &info->reg->flash_nf_address_1);
+		/* Issue command */
+		writel(NFLASH_GO, &info->reg->flash_flash_access_start);
+		break;
+	case NAND_CMD_ERASE2:
+		return;
+	case NAND_CMD_STATUS:
+		writel(NAND_CMD_STATUS, &info->reg->flash_nf_command);
+		/* 1 byte CMD cycle */
+		clrbits_le32(&info->reg->flash_nf_count, GENMASK(1, 0));
+		/* 0 byte Addr cycle */
+		setbits_le32(&info->reg->flash_nf_count, GENMASK(6, 4));
+		/* 1 Data cycle */
+		clrbits_le32(&info->reg->flash_nf_count, GENMASK(21, 8));
+		/* 0 OOB cycle */
+		setbits_le32(&info->reg->flash_nf_count, GENMASK(31, 22));
+
+		break;
+	case NAND_CMD_RESET:
+		writel(NAND_CMD_RESET, &info->reg->flash_nf_command);
+		/* 1 byte CMD cycle */
+		clrbits_le32(&info->reg->flash_nf_count, GENMASK(1, 0));
+		/* 0 byte Addr cycle */
+		setbits_le32(&info->reg->flash_nf_count, GENMASK(6, 4));
+		/* 0 Data cycle */
+		setbits_le32(&info->reg->flash_nf_count, GENMASK(21, 8));
+		/* 0 OOB cycle */
+		setbits_le32(&info->reg->flash_nf_count, GENMASK(31, 22));
+
+		writel(column & 0xFF, &info->reg->flash_nf_address_1);
+
+		/* clear FLASH_NF_ACCESS */
+		clrbits_le32(&info->reg->flash_nf_access, AUTO_RESET | NFLASH_ENABLE_ALTERNATIVE | NFLASH_REG_WIDTH_8);
+		writel(NFLASH_WT | NFLASH_GO, &info->reg->flash_flash_access_start);
+
+		break;
+	case NAND_CMD_RNDOUT:
+	default:
+		printf("%s: Unsupported command %d\n", __func__, command);
+		return;
+	}
+	if (!nand_waitfor_cmd_completion(info->reg))
+		printf("Command 0x%02X timeout\n", command);
+}
+
+/**
+ * Check whether the pointed buffer are all 0xff (blank).
+ *
+ * @param buf	data buffer for blank check
+ * @param len	length of the buffer in byte
+ * @return
+ *	1 - blank
+ *	0 - non-blank
+ */
+static int blank_check(u8 *buf, int len)
+{
+	int i;
+
+	for (i = 0; i < len; i++)
+		if (buf[i] != 0xFF)
+			return 0;
+	return 1;
+}
+
+/**
+ * After a DMA transfer for read, we call this function to see whether there
+ * is any uncorrectable error on the pointed data buffer or oob buffer.
+ *
+ * @param reg		nand_ctlr structure
+ * @param databuf	data buffer
+ * @param a_len		data buffer length
+ * @param oobbuf	oob buffer
+ * @param b_len		oob buffer length
+ * @return
+ *	ECC_OK - no ECC error or correctable ECC error
+ *	ECC_TAG_ERROR - uncorrectable tag ECC error
+ *	ECC_DATA_ERROR - uncorrectable data ECC error
+ *	ECC_DATA_ERROR + ECC_TAG_ERROR - uncorrectable data+tag ECC error
+ */
+static int check_ecc_error(struct nand_ctlr *reg, u8 *databuf,
+			   int a_len, u8 *oobbuf, int b_len)
+{
+#if 0
+	int return_val = ECC_OK;
+	u32 reg_val;
+
+	if (!(readl(&reg->isr) & ISR_IS_ECC_ERR))
+		return ECC_OK;
+
+	/*
+	 * Area A is used for the data block (databuf). Area B is used for
+	 * the spare block (oobbuf)
+	 */
+	reg_val = readl(&reg->dec_status);
+	if ((reg_val & DEC_STATUS_A_ECC_FAIL) && databuf) {
+		reg_val = readl(&reg->bch_dec_status_buf);
+		/*
+		 * If uncorrectable error occurs on data area, then see whether
+		 * they are all FF. If all are FF, it's a blank page.
+		 * Not error.
+		 */
+		if ((reg_val & BCH_DEC_STATUS_FAIL_SEC_FLAG_MASK) &&
+		    !blank_check(databuf, a_len))
+			return_val |= ECC_DATA_ERROR;
+	}
+
+	if ((reg_val & DEC_STATUS_B_ECC_FAIL) && oobbuf) {
+		reg_val = readl(&reg->bch_dec_status_buf);
+		/*
+		 * If uncorrectable error occurs on tag area, then see whether
+		 * they are all FF. If all are FF, it's a blank page.
+		 * Not error.
+		 */
+		if ((reg_val & BCH_DEC_STATUS_FAIL_TAG_MASK) &&
+		    !blank_check(oobbuf, b_len))
+			return_val |= ECC_TAG_ERROR;
+	}
+
+	return return_val;
+#endif
+	return 0;
+}
+
+/**
+ * Set GO bit to send command to device
+ *
+ * @param reg	nand_ctlr structure
+ */
+static void start_command(struct nand_ctlr *reg)
+{
+#if 0
+	u32 reg_val;
+
+	reg_val = readl(&reg->command);
+	reg_val |= CMD_GO;
+	writel(reg_val, &reg->command);
+#endif
+}
+
+/**
+ * Clear command GO bit, DMA GO bit, and DMA completion status
+ *
+ * @param reg	nand_ctlr structure
+ */
+static void stop_command(struct nand_ctlr *reg, struct dma_global *dma_glb)
+{
+#if 1
+	/* Stop command */
+	//writel(0, &reg->command);
+	clrbits_le32(&reg->flash_flash_access_start, NFLASH_GO);
+	printf("flash_flash_access_start: %x\n", readl(&reg->flash_flash_access_start));
+
+	/* Stop DMA engine and clear DMA completion status */
+//	writel(DMA_MST_CTRL_GO_DISABLE
+//		| DMA_MST_CTRL_IS_DMA_DONE,
+//		&reg->dma_mst_ctrl);
+	clrbits_le32(&dma_glb->dma_glb_dma_lso_ctrl, TX_DMA_ENABLE);
+	printf("dma_glb_dma_lso_ctrl: %x\n", readl(&dma_glb->dma_glb_dma_lso_ctrl));
+	clrbits_le32(&dma_glb->dma_glb_dma_ssp_rx_ctrl, TX_DMA_ENABLE);
+	printf("dma_glb_dma_ssp_rx_ctrl: %x\n", readl(&dma_glb->dma_glb_dma_ssp_rx_ctrl));
+	clrbits_le32(&dma_glb->dma_glb_dma_ssp_tx_ctrl, RX_DMA_ENABLE);
+	printf("dma_glb_dma_ssp_tx_ctrl: %x\n", readl(&dma_glb->dma_glb_dma_ssp_tx_ctrl));
+#endif
+}
+
+/**
+ * Set up NAND bus width and page size
+ *
+ * @param info		nand_info structure
+
+ * @return 0 if ok, -1 on error
+ */
+static int set_bus_width_page_size(struct mtd_info *our_mtd)
+{
+	struct nand_chip *chip = mtd_to_nand(our_mtd);
+	struct nand_drv *info;
+
+	printf("set_bus_sidth_page_size start!\n");
+	printf("our_mtd->writesize: %d\n", our_mtd->writesize);
+
+	info = (struct nand_drv *)nand_get_controller_data(chip);
+	printf("info->config.width: %d\n", info->config.width);
+
+	if (info->config.width == 8)
+		setbits_le32(&info->reg->flash_nf_access, NFLASH_REG_WIDTH_8);
+	else if (info->config.width == 16)
+		setbits_le32(&info->reg->flash_nf_access, NFLASH_REG_WIDTH_16);
+	else {
+		debug("%s: Unsupported bus width %d\n", __func__,
+		      info->config.width);
+		return -1;
+	}
+
+	if (our_mtd->writesize == 512)
+		setbits_le32(&info->reg->flash_type, FLASH_TYPE_512);
+	else if (our_mtd->writesize == 2048)
+		setbits_le32(&info->reg->flash_type, FLASH_TYPE_2K);
+	else if (our_mtd->writesize == 4096)
+		setbits_le32(&info->reg->flash_type, FLASH_TYPE_4K);
+	else {
+		debug("%s: Unsupported page size %d\n", __func__,
+		      our_mtd->writesize);
+		return -1;
+	}
+
+	printf("set_bus_sidth_page_size done!\n");
+	return 0;
+}
+
+static int ca_do_bch_decode(struct mtd_info *mtd, struct nand_chip *chip,
+			    u8 *buf, int page)
+{
+	struct nand_drv *info;
+	unsigned int reg_v, err_num, err_loc0, err_loc1;
+	unsigned char *ecc_code;
+	int ret, i, j, k, step;
+	u8 *buff_ptr = buf;
+
+	info = (struct nand_drv *)nand_get_controller_data(chip);
+	/* Empty page, ECC check is unnecessary */
+	if (chip->oob_poi[eccoob.oobfree[0].length] == 0xFF)
+		return 0;
+
+	ecc_code = &chip->oob_poi[eccoob.oobfree[0].length + 1];
+	for (i = 0; i < chip->ecc.total; i += chip->ecc.bytes) {
+		for (j = 0; j < chip->ecc.bytes; j += 4) {
+			reg_v = ecc_code[j + i] | (ecc_code[1 + j + i] << 8) | \
+					(ecc_code[2 + j + i] << 16) | (ecc_code[3 + j + i] << 24);
+			writel(reg_v, &info->reg->flash_nf_bch_oob0 + j);
+		}
+
+		/* Clear ECC buffer */
+		setbits_le32(&info->reg->flash_nf_ecc_reset, RESET_NFLASH_ECC);
+		ret = readl_poll_timeout(&info->reg->flash_nf_ecc_reset, reg_v,
+					 !(reg_v & RESET_NFLASH_ECC),
+				 FLASH_SHORT_DELAY);
+		if (ret)
+			pr_err("Reset ECC buffer fail\n");
+
+		step = i / chip->ecc.bytes;
+		clrsetbits_le32(&info->reg->flash_nf_bch_control, \
+				GENMASK(6, 4), step << 4);
+
+		/* Start  */
+		setbits_le32(&info->reg->flash_nf_bch_control, BCH_ENABLE);
+		setbits_le32(&info->reg->flash_nf_bch_control, BCH_COMPARE);
+
+		ret = readl_poll_timeout(&info->reg->flash_nf_bch_status, reg_v,
+					 (reg_v & BCH_DECO_DONE), FLASH_SHORT_DELAY);
+		if (ret)
+			pr_err("ECC Decode timeout\n");
+
+		/* Stop compare */
+		clrbits_le32(&info->reg->flash_nf_bch_control, BCH_COMPARE);
+
+		reg_v = readl(&info->reg->flash_nf_bch_status);
+		err_num = (reg_v >> 8) & 0x3F;
+		reg_v &= BCH_ERR_MASK;
+		/* Uncorrectable */
+		if (reg_v == BCH_UNCORRECTABLE) {
+			pr_err("Uncorrectable error\n");
+			pr_err(" Page:%x  step:%d\n", page, step);
+			break;
+		}
+
+		/* Do ECC correction */
+		if (reg_v == BCH_CORRECTABLE_ERR) {
+			for (k = 0; k < err_num ; k += 2) {
+				reg_v = readl(&info->reg->flash_nf_bch_error_loc01 + k * 2);
+				err_loc0 = reg_v & 0x0000FFFF;
+				err_loc1 = reg_v >> 16;
+
+				if (err_loc0 / 8 < BCH_DATA_UNIT)
+					buff_ptr[err_loc0 / 8] ^= (1 << (err_loc0 & 0x07));
+
+				if ((err_num & 1) && ((err_loc1 / 8) < BCH_DATA_UNIT))
+						buff_ptr[err_loc1 / 8] ^= (1 << (err_loc1 & 0x07));
+			}
+		}
+		buff_ptr += BCH_DATA_UNIT;
+	}
+
+	return 0;
+}
+
+static int ca_do_bch_encode(struct mtd_info *mtd, struct nand_chip *chip,
+			    u8 *buf, int page)
+{
+	struct nand_drv *info;
+	unsigned int reg_v, err_num, err_loc0, err_loc1;
+	unsigned char *ecc_code;
+	int ret, i, j, k, step;
+	u8 *buff_ptr = buf;
+
+	info = (struct nand_drv *)nand_get_controller_data(chip);
+	/* Empty page, ECC check is unnecessary */
+	if (chip->oob_poi[eccoob.oobfree[0].length] == 0xFF)
+		return 0;
+
+	ecc_code = &chip->oob_poi[eccoob.oobfree[0].length + 1];
+	for (i = 0; i < chip->ecc.total; i += chip->ecc.bytes) {
+		for (j = 0; j < chip->ecc.bytes; j += 4) {
+			reg_v = ecc_code[j + i] | (ecc_code[1 + j + i] << 8) | \
+					(ecc_code[2 + j + i] << 16) | (ecc_code[3 + j + i] << 24);
+			writel(reg_v, &info->reg->flash_nf_bch_oob0 + j);
+		}
+
+		/* Clear ECC buffer */
+		setbits_le32(&info->reg->flash_nf_ecc_reset, RESET_NFLASH_ECC);
+		ret = readl_poll_timeout(&info->reg->flash_nf_ecc_reset, reg_v,
+					 !(reg_v & RESET_NFLASH_ECC),
+				 FLASH_SHORT_DELAY);
+		if (ret)
+			pr_err("Reset ECC buffer fail\n");
+
+		step = i / chip->ecc.bytes;
+		clrsetbits_le32(&info->reg->flash_nf_bch_control, \
+				GENMASK(6, 4), step << 4);
+
+		/* Start  */
+		setbits_le32(&info->reg->flash_nf_bch_control, BCH_ENABLE);
+		setbits_le32(&info->reg->flash_nf_bch_control, BCH_COMPARE);
+
+		ret = readl_poll_timeout(&info->reg->flash_nf_bch_status, reg_v,
+					 (reg_v & BCH_DECO_DONE), FLASH_SHORT_DELAY);
+		if (ret)
+			pr_err("ECC Decode timeout\n");
+	}
+
+	return 0;
+}
+
+/**
+ * Page read/write function
+ *
+ * @param mtd		mtd info structure
+ * @param chip		nand chip info structure
+ * @param buf		data buffer
+ * @param page		page number
+ * @param with_ecc	1 to enable ECC, 0 to disable ECC
+ * @param is_writing	0 for read, 1 for write
+ * @return	0 when successfully completed
+ *		-EIO when command timeout
+ */
+static int nand_rw_page(struct mtd_info *mtd, struct nand_chip *chip,
+			u8 *buf, int page, int with_ecc, int is_writing)
+{
+	struct nand_drv *info;
+	unsigned int reg_v, ext_addr, addr, dma_index;
+	struct tx_descriptor_t *tx_desc;
+	struct rx_descriptor_t *rx_desc;
+	int ret;
+
+	info = (struct nand_drv *)nand_get_controller_data(chip);
+
+	if (with_ecc == 1) {
+		switch (info->config.nand_ecc_strength) {
+		case 8:
+			reg_v = BCH_ERR_CAP_8;
+			break;
+		case 16:
+			reg_v = BCH_ERR_CAP_16;
+			break;
+		case 24:
+			reg_v = BCH_ERR_CAP_24;
+			break;
+		case 40:
+			reg_v = BCH_ERR_CAP_40;
+			break;
+		default:
+			reg_v = BCH_ERR_CAP_16;
+			break;
+		}
+		reg_v |= BCH_ENABLE;
+		/* BCH decode for flash read */
+		if (is_writing == 0)
+			reg_v |= BCH_DECODE;
+		writel(reg_v, &info->reg->flash_nf_bch_control);
+	} else {
+		writel(0, &info->reg->flash_nf_bch_control);
+	}
+
+	/* Disable TXQ */
+	clrbits_le32(&info->dma_nand->dma_q_txq_control, GENMASK(0, 0));
+
+	/* Clear interrupt */
+	setbits_le32(&info->dma_nand->dma_q_rxq_coal_interrupt, GENMASK(0, 0));
+	setbits_le32(&info->dma_nand->dma_q_txq_coal_interrupt, GENMASK(0, 0));
+
+	/* Fill Extend address */
+	ext_addr = ((page << chip->page_shift) / 0x8000000);
+	clrsetbits_le32(&info->reg->flash_nf_access, \
+				GENMASK(7, 0), (uintptr_t)ext_addr);
+
+	addr =  (uintptr_t)((page << chip->page_shift) % 0x8000000);
+	addr = (uintptr_t)(addr + info->flash_base);
+
+	dma_index = readl(&info->dma_nand->dma_q_txq_wptr) & \
+				CA_DMA_Q_PTR_MASK;
+
+	tx_desc = info->tx_desc;
+	rx_desc = info->rx_desc;
+
+	/* TX/RX descriptor for page data */
+	tx_desc[dma_index].own = OWN_DMA;
+	tx_desc[dma_index].buf_len = mtd->writesize;
+	rx_desc[dma_index].own = OWN_DMA;
+	rx_desc[dma_index].buf_len = mtd->writesize;
+	if (is_writing == 0) {
+		tx_desc[dma_index].buf_adr = (uintptr_t)addr;
+		rx_desc[dma_index].buf_adr = (uintptr_t)(buf);
+	} else {
+		tx_desc[dma_index].buf_adr = (uintptr_t)buf;
+		rx_desc[dma_index].buf_adr = (uintptr_t)(addr);
+	}
+
+	dma_index++;
+	dma_index %= CA_DMA_DESC_NUM;
+
+	if ((with_ecc == 1) && (is_writing == 0)) {
+		/* TX/RX descriptor for OOB area */
+		addr = (uintptr_t)(addr + mtd->writesize);
+		tx_desc[dma_index].own = OWN_DMA;
+		tx_desc[dma_index].buf_len = mtd->oobsize;
+		tx_desc[dma_index].buf_adr = (uintptr_t)addr;
+		rx_desc[dma_index].own = OWN_DMA;
+		rx_desc[dma_index].buf_len = mtd->oobsize;
+		rx_desc[dma_index].buf_adr = (uintptr_t)(chip->oob_poi);
+		dma_index++;
+		dma_index %= CA_DMA_DESC_NUM;
+	}
+
+	if (is_writing == 1)
+		clrsetbits_le32(&info->reg->flash_fifo_control, GENMASK(1, 0), FIFO_WRITE);
+	else
+		clrsetbits_le32(&info->reg->flash_fifo_control, GENMASK(1, 0), FIFO_READ);
+
+	/* Start FIFO request */
+	setbits_le32(&info->reg->flash_flash_access_start, NFLASH_FIFO_REQ);
+
+	/* Update DMA R/W pointer */
+	clrsetbits_le32(&info->dma_nand->dma_q_txq_wptr, GENMASK(12, 0), dma_index);
+	clrsetbits_le32(&info->dma_nand->dma_q_rxq_rptr, GENMASK(12, 0), dma_index);
+
+	/* Start DMA */
+	setbits_le32(&info->dma_nand->dma_q_txq_control, GENMASK(0, 0));
+
+	/* Wait TX DMA done */
+	ret = readl_poll_timeout(&info->dma_nand->dma_q_txq_coal_interrupt, reg_v,
+				 (reg_v & 1), FLASH_LONG_DELAY);
+	if (ret) {
+		pr_err("TX DMA timeout\n");
+		return -ETIMEDOUT;
+	}
+	setbits_le32(&info->dma_nand->dma_q_txq_coal_interrupt, 1);
+
+	/* Wait RX DMA done */
+	ret = readl_poll_timeout(&info->dma_nand->dma_q_rxq_coal_interrupt, reg_v,
+				 (reg_v & 1), FLASH_LONG_DELAY);
+	if (ret) {
+		pr_err("RX DMA timeout\n");
+		return -ETIMEDOUT;
+	}
+	setbits_le32(&info->dma_nand->dma_q_rxq_coal_interrupt, 1);
+
+	/* ECC correction */
+	if (with_ecc == 1) {
+		ret = readl_poll_timeout(&info->reg->flash_nf_bch_status, reg_v,
+					 (reg_v & BCH_GEN_DONE), FLASH_LONG_DELAY);
+		if (ret) {
+			pr_err("BCH_GEN timeout! flash_nf_bch_status=[0x%x]\n", reg_v);
+			return -ETIMEDOUT;
+		}
+
+		if (is_writing == 0)
+			ca_do_bch_decode(mtd, chip, buf, page);
+		else
+			ca_do_bch_encode(mtd, chip, buf, page);
+	}
+
+	return 0;
+}
+
+/**
+ * Hardware ecc based page read function
+ *
+ * @param mtd	mtd info structure
+ * @param chip	nand chip info structure
+ * @param buf	buffer to store read data
+ * @param page	page number to read
+ * @return	0 when successfully completed
+ *		-EIO when command timeout
+ */
+static int nand_read_page_hwecc(struct mtd_info *mtd,
+				struct nand_chip *chip, uint8_t *buf, int oob_required, int page)
+{
+	return nand_rw_page(mtd, chip, buf, page, 1, 0);
+}
+
+/**
+ * Hardware ecc based page write function
+ *
+ * @param mtd	mtd info structure
+ * @param chip	nand chip info structure
+ * @param buf	data buffer
+ */
+static int nand_write_page_hwecc(struct mtd_info *mtd,
+				 struct nand_chip *chip, const uint8_t *buf, int oob_required,
+	int page)
+{
+	nand_rw_page(mtd, chip, (uint8_t *)buf, page, 1, 1);
+	return 0;
+}
+
+/**
+ * Read raw page data without ecc
+ *
+ * @param mtd	mtd info structure
+ * @param chip	nand chip info structure
+ * @param buf	buffer to store read data
+ * @param page	page number to read
+ * @return	0 when successfully completed
+ *		-EINVAL when chip->oob_poi is not double-word aligned
+ *		-EIO when command timeout
+ */
+static int nand_read_page_raw(struct mtd_info *mtd,
+			      struct nand_chip *chip, uint8_t *buf, int oob_required, int page)
+{
+	return nand_rw_page(mtd, chip, buf, page, 0, 0);
+}
+
+/**
+ * Raw page write function
+ *
+ * @param mtd	mtd info structure
+ * @param chip	nand chip info structure
+ * @param buf	data buffer
+ */
+static int nand_write_page_raw(struct mtd_info *mtd,
+			       struct nand_chip *chip,	const uint8_t *buf,
+		int oob_required, int page)
+{
+	nand_rw_page(mtd, chip, (uint8_t *)buf, page, 0, 1);
+	return 0;
+}
+
+/**
+ * OOB data read/write function
+ *
+ * @param mtd		mtd info structure
+ * @param chip		nand chip info structure
+ * @param page		page number to read
+ * @param with_ecc	1 to enable ECC, 0 to disable ECC
+ * @param is_writing	0 for read, 1 for write
+ * @return	0 when successfully completed
+ *		-EINVAL when chip->oob_poi is not double-word aligned
+ *		-EIO when command timeout
+ */
+static int nand_rw_oob(struct mtd_info *mtd, struct nand_chip *chip,
+		       int page, int with_ecc, int is_writing)
+{
+	u32 reg_val;
+	int tag_size;
+	struct nand_oobfree *free = chip->ecc.layout->oobfree;
+	struct nand_drv *info;
+	unsigned int bbflags;
+	//struct bounce_buffer bbstate_oob;
+	printf("nand_rw_oob functiont start!\n");
+
+	printf("chip->oob_poi: %x\n", (uintptr_t)chip->oob_poi & 0x03);
+	if (((uintptr_t)chip->oob_poi) & 0x03)
+	{
+		printf("chip->poi & 3 != 0\n");
+		return -EINVAL;
+	}
+	info = (struct nand_drv *)nand_get_controller_data(chip);
+	if (set_bus_width_page_size(mtd))
+		return -EINVAL;
+
+	stop_command(info->reg, info->dma_glb);
+#if 0
+
+	/* Set ECC selection */
+	tag_size = mtd->oobsize;
+	if (with_ecc)
+		setbits_le32(&info->reg->flash_nf_ecc_control, ENABLE_ECC_GENERATION);
+	else
+		clrbits_le32(&info->reg->flash_nf_ecc_control, ENABLE_ECC_GENERATION);
+
+	reg_val |= ((tag_size - 1) |
+		CFG_SKIP_SPARE_DISABLE |
+		CFG_HW_ECC_CORRECTION_DISABLE |
+		CFG_HW_ECC_DISABLE);
+	writel(reg_val, &info->reg->config);
+
+	if (is_writing && with_ecc)
+		tag_size -= TAG_ECC_BYTES;
+
+	if (is_writing)
+		bbflags = GEN_BB_READ;
+	else
+		bbflags = GEN_BB_WRITE;
+
+	//bounce_buffer_start(&bbstate_oob, (void *)chip->oob_poi, tag_size,
+		//	    bbflags);
+	//writel(virt_to_phys(bbstate_oob.bounce_buffer), &info->reg->tag_ptr);
+
+	writel(BCH_CONFIG_BCH_ECC_DISABLE, &info->reg->bch_config);
+
+	writel(tag_size - 1, &info->reg->dma_cfg_b);
+
+	reg_val = CMD_CLE | CMD_ALE
+		| CMD_SEC_CMD
+		| (CMD_ALE_BYTES5 << CMD_ALE_BYTE_SIZE_SHIFT)
+		| CMD_B_VALID
+		| CMD_CE0;
+	if (!is_writing)
+		reg_val |= (CMD_AFT_DAT_DISABLE | CMD_RX);
+	else
+		reg_val |= (CMD_AFT_DAT_ENABLE | CMD_TX);
+	writel(reg_val, &info->reg->command);
+
+	/* Setup DMA engine */
+	reg_val = DMA_MST_CTRL_GO_ENABLE
+		| DMA_MST_CTRL_BURST_8WORDS
+		| DMA_MST_CTRL_EN_B_ENABLE;
+	if (!is_writing)
+		reg_val |= DMA_MST_CTRL_DIR_READ;
+	else
+		reg_val |= DMA_MST_CTRL_DIR_WRITE;
+
+	writel(reg_val, &info->reg->dma_mst_ctrl);
+
+	start_command(info->reg);
+
+	if (!nand_waitfor_cmd_completion(info->reg)) {
+		if (!is_writing)
+			printf("Read OOB of Page 0x%X timeout\n", page);
+		else
+			printf("Write OOB of Page 0x%X timeout\n", page);
+		return -EIO;
+	}
+
+	//bounce_buffer_stop(&bbstate_oob);
+
+	if (with_ecc && !is_writing) {
+		reg_val = (u32)check_ecc_error(info->reg, 0, 0,
+			(u8 *)(chip->oob_poi + free->offset),
+			chip->ecc.layout->oobavail);
+		if (reg_val & ECC_TAG_ERROR)
+			printf("Read OOB of Page 0x%X tag ECC error\n", page);
+	}
+#endif
+	return 0;
+}
+
+/**
+ * OOB data read function
+ *
+ * @param mtd		mtd info structure
+ * @param chip		nand chip info structure
+ * @param page		page number to read
+ */
+static int nand_read_oob(struct mtd_info *mtd, struct nand_chip *chip,
+			 int page)
+{
+	printf("nand_read_oob function start!\n");
+	chip->cmdfunc(mtd, NAND_CMD_READOOB, 0, page);
+	nand_rw_oob(mtd, chip, page, 0, 0);
+	return 0;
+}
+
+/**
+ * OOB data write function
+ *
+ * @param mtd	mtd info structure
+ * @param chip	nand chip info structure
+ * @param page	page number to write
+ * @return	0 when successfully completed
+ *		-EINVAL when chip->oob_poi is not double-word aligned
+ *		-EIO when command timeout
+ */
+static int nand_write_oob(struct mtd_info *mtd, struct nand_chip *chip,
+			  int page)
+{
+	chip->cmdfunc(mtd, NAND_CMD_SEQIN, mtd->writesize, page);
+
+	return nand_rw_oob(mtd, chip, page, 0, 1);
+}
+
+/**
+ * Set up NAND memory timings according to the provided parameters
+ *
+ * @param timing	Timing parameters
+ * @param reg		NAND controller register address
+ */
+static void setup_timing(unsigned int timing[FDT_NAND_TIMING_COUNT],
+			 struct nand_ctlr *reg)
+{
+	/* TBD */
+}
+
+/**
+ * Decode NAND parameters from the device tree
+ *
+ * @param dev		Driver model device
+ * @param config	Device tree NAND configuration
+ * @return 0 if ok, -ve on error (FDT_ERR_...)
+ */
+static int fdt_decode_nand(struct udevice *dev, struct nand_drv *info)
+{
+	int ecc_strength;
+
+	info->reg = (struct nand_ctlr *)dev_read_addr(dev);
+	info->dma_glb = (struct dma_global *)dev_read_addr_index(dev, 1);
+	info->dma_nand = (struct dma_ssp *)dev_read_addr_index(dev, 2);
+	info->config.enabled = dev_read_enabled(dev);
+	ecc_strength = dev_read_u32_default(dev, "nand-ecc-strength", 16);
+	info->flash_base = dev_read_u32_default(dev, "nand_flash_base_addr", 0xE0000000);
+
+	switch (ecc_strength) {
+	case 8:
+		info->config.nand_ecc_strength = 8;
+	case 16:
+		info->config.nand_ecc_strength = 16;
+	case 24:
+		info->config.nand_ecc_strength = 24;
+	case 40:
+		info->config.nand_ecc_strength = 40;
+	default:
+		info->config.nand_ecc_strength = 16;
+	}
+
+	return 0;
+}
+
+static void nand_config_flash_type(struct nand_chip *nand)
+{
+	struct nand_drv *info;
+	struct mtd_info *mtd = nand_to_mtd(nand);
+
+	info = (struct nand_drv *)nand_get_controller_data(nand);
+
+	switch (mtd->writesize) {
+	case 512:
+		writel(FLASH_TYPE_512, &info->reg->flash_type);
+		break;
+	case 2048:
+		writel(FLASH_PIN | FLASH_TYPE_2K, &info->reg->flash_type);
+		break;
+	case 4096:
+		writel(FLASH_PIN | FLASH_TYPE_4K, &info->reg->flash_type);
+		break;
+	case 8192:
+		writel(FLASH_PIN | FLASH_TYPE_8K, &info->reg->flash_type);
+		break;
+	default:
+		pr_err("Unsupported page size(0x%x)!", nand->ecc.size);
+	}
+
+	return;
+}
+
+static int nand_config_oob_layout(struct nand_chip *nand)
+{
+	int i, eccStartOffset;
+	struct mtd_info *mtd = nand_to_mtd(nand);
+
+	/* Calculate byte count for ECC */
+	printf("nand->ecc.size: %d, nand->ecc.strength: %d\n", nand->ecc.size, nand->ecc.strength);
+//	eccoob.eccbytes = (nand->ecc.size / BCH_DATA_UNIT) * \
+//		(nand->ecc.strength / 8) * BCH_GF_PARAM_M ;
+	eccoob.eccbytes = mtd->writesize / nand->ecc.size * nand->ecc.bytes;
+	printf("eccoob.eccbytes %d\n", eccoob.eccbytes);
+
+	if (mtd->oobsize < eccoob.eccbytes) {
+		pr_err("Spare area(%d) too small for BCH%d\n", nand->ecc.bytes, \
+				nand->ecc.strength / 8);
+		pr_err("page_sz: %d\n", nand->ecc.size);
+		pr_err("oob_sz: %d\n", nand->ecc.bytes);
+		return -EINVAL;
+	}
+
+	/* Update OOB layout */
+	eccStartOffset = nand->ecc.bytes - eccoob.eccbytes;
+	memset(eccoob.eccpos, 0, sizeof(eccoob.eccpos));
+	for (i = 0 ; i < eccoob.eccbytes; ++i)
+			eccoob.eccpos[i] = i + eccStartOffset;
+
+	/* Unused spare area
+	 * OOB[0] is bad block marker.
+	 * Extra one byte is reservered as erase marker just rigth before ECC code.
+	 */
+	eccoob.oobavail = nand->ecc.bytes - eccoob.eccbytes - 2;
+	eccoob.oobfree[0].offset = 1;
+	eccoob.oobfree[0].length = eccoob.oobavail;
+
+	return 0;
+}
+
+static int ca_nand_probe(struct udevice *dev)
+{
+	struct ca_nand_info *ca_nand = dev_get_priv(dev);
+	struct nand_chip *nand = &ca_nand->nand_chip;
+	struct nand_drv *info = &ca_nand->nand_ctrl;
+	struct fdt_nand *config = &info->config;
+	struct mtd_info *our_mtd;
+	int ret;
+
+	if (fdt_decode_nand(dev, info)) {
+		printf("Could not decode nand-flash in device tree\n");
+		return -1;
+	}
+	if (!config->enabled)
+		return -1;
+	nand->ecc.mode = NAND_ECC_HW;
+	nand->ecc.layout = &eccoob;
+
+	nand->cmdfunc = ca_nand_command;
+	nand->read_byte = read_byte;
+	nand->read_buf = read_buf;
+	nand->ecc.read_page = nand_read_page_hwecc;
+	nand->ecc.write_page = nand_write_page_hwecc;
+	nand->ecc.read_page_raw = nand_read_page_raw;
+	nand->ecc.write_page_raw = nand_write_page_raw;
+	nand->ecc.read_oob = nand_read_oob;
+	nand->ecc.write_oob = nand_write_oob;
+	nand->ecc.strength = config->nand_ecc_strength;
+	nand->select_chip = nand_select_chip;
+	nand->block_bad = block_bad;
+	nand->dev_ready  = nand_dev_ready;
+	nand_set_controller_data(nand, &ca_nand->nand_ctrl);
+
+	/* Disable subpage writes as we do not provide ecc->hwctl */
+	printf("nand->ecc.read_oob: %p\n", nand->ecc.read_oob);
+	nand->options |= NAND_NO_SUBPAGE_WRITE | NAND_SKIP_BBTSCAN;
+
+	/* Adjust timing for NAND device */
+	setup_timing(config->timing, info->reg);
+
+	/* Configure flash type as P-NAND */
+	clrsetbits_le32(&info->reg->flash_type, FLASH_PIN, FLASH_TYPE_4K | FLASH_SIZE_436OOB);
+	config->width = FLASH_WIDTH;
+
+	our_mtd = nand_to_mtd(nand);
+	ret = nand_scan_ident(our_mtd, CONFIG_SYS_NAND_MAX_CHIPS, NULL);
+	if (ret)
+		return ret;
+	printf("nand->options: %x\n", nand->options);
+
+	pr_debug("Page size=0x%d\n", our_mtd->writesize);
+	pr_debug("OOB size=0x%d\n", our_mtd->oobsize);
+	nand->ecc.size = BCH_DATA_UNIT;
+	nand->ecc.bytes = BCH_GF_PARAM_M * (nand->ecc.strength / 8);
+	pr_debug("ecc_size=0x%d\n", nand->ecc.size);
+	pr_debug("ecc_bytes=0x%d\n", nand->ecc.bytes);
+	pr_debug("ecc_strength=0x%d\n", nand->ecc.strength);
+	/* Reconfig flash type according to ONFI */
+	nand_config_flash_type(nand);
+	printf("nand_config_flash_type ONFI done!\n");
+	printf("nand->options1: %x\n", nand->options);
+
+	/* Set the bad block position */
+	nand->badblockpos = our_mtd->writesize > 512 ? NAND_LARGE_BADBLOCK_POS : NAND_SMALL_BADBLOCK_POS;
+	printf("nand->options2: %x\n", nand->options);
+
+	/* Arrange OOB layout */
+	ret = nand_config_oob_layout(nand);
+	if (ret)
+		return ret;
+	printf("nand->options3: %x\n", nand->options);
+	printf("config oob layout done!\n");
+	/* Init DMA descriptor ring */
+	ret = init_nand_dma(nand);
+	printf("DMA done!\n");
+	if (ret)
+		return ret;
+	printf("nand->options4: %x\n", nand->options);
+
+	ret = nand_scan_tail(our_mtd);
+	printf("nand scan tail done!\n");
+	if (ret)
+		return ret;
+
+	ret = nand_register(0, our_mtd);
+	printf("nand register done!\n");
+	if (ret) {
+		dev_err(dev, "Failed to register MTD: %d\n", ret);
+		return ret;
+	}
+
+	return 0;
+}
+
+U_BOOT_DRIVER(cortina_nand) = {
+	.name = "CA-PNAND",
+	.id = UCLASS_MTD,
+	.of_match = cortina_nand_dt_ids,
+	.probe = ca_nand_probe,
+	.priv_auto_alloc_size = sizeof(struct ca_nand_info),
+};
+
+void board_nand_init(void)
+{
+	struct udevice *dev;
+	int ret;
+
+	ret = uclass_get_device_by_driver(UCLASS_MTD,
+					  DM_GET_DRIVER(cortina_nand), &dev);
+	if (ret && ret != -ENODEV)
+		pr_err("Failed to initialize %s. (error %d)\n", dev->name,
+		       ret);
+}
diff --git a/drivers/mtd/nand/raw/cortina_nand.h b/drivers/mtd/nand/raw/cortina_nand.h
new file mode 100644
index 0000000..1dd53a0
--- /dev/null
+++ b/drivers/mtd/nand/raw/cortina_nand.h
@@ -0,0 +34,690 @@
+/* SPDX-License-Identifier: GPL-2.0+ */
+/*
+ * (C) Copyright 2011 NVIDIA Corporation <www.nvidia.com>
+ */
+
+/* register offset */
+#define COMMAND_0		0x00
+#define CMD_GO			BIT(31)
+#define CMD_CLE			BIT(30)
+#define CMD_ALE			BIT(29)
+#define CMD_PIO			BIT(28)
+#define CMD_TX			BIT(27)
+#define CMD_RX			BIT(26)
+#define CMD_SEC_CMD		BIT(25)
+#define CMD_AFT_DAT_MASK	BIT(24)
+#define CMD_AFT_DAT_DISABLE	0
+#define CMD_AFT_DAT_ENABLE	BIT(24)
+#define CMD_TRANS_SIZE_SHIFT	20
+#define CMD_TRANS_SIZE_PAGE	8
+#define CMD_A_VALID		BIT(19)
+#define CMD_B_VALID		BIT(18)
+#define CMD_RD_STATUS_CHK	BIT(17)
+#define CMD_R_BSY_CHK		BIT(16)
+#define CMD_CE7			BIT(15)
+#define CMD_CE6			BIT(14)
+#define CMD_CE5			BIT(13)
+#define CMD_CE4			BIT(12)
+#define CMD_CE3			BIT(11)
+#define CMD_CE2			BIT(10)
+#define CMD_CE1			BIT(9)
+#define CMD_CE0			BIT(8)
+#define CMD_CLE_BYTE_SIZE_SHIFT	4
+enum {
+	CMD_CLE_BYTES1 = 0,
+	CMD_CLE_BYTES2,
+	CMD_CLE_BYTES3,
+	CMD_CLE_BYTES4,
+};
+
+#define CMD_ALE_BYTE_SIZE_SHIFT	0
+enum {
+	CMD_ALE_BYTES1 = 0,
+	CMD_ALE_BYTES2,
+	CMD_ALE_BYTES3,
+	CMD_ALE_BYTES4,
+	CMD_ALE_BYTES5,
+	CMD_ALE_BYTES6,
+	CMD_ALE_BYTES7,
+	CMD_ALE_BYTES8
+};
+
+#define STATUS_0			0x04
+#define STATUS_RBSY0			BIT(8)
+
+#define ISR_0				0x08
+#define ISR_IS_CMD_DONE			BIT(5)
+#define ISR_IS_ECC_ERR			BIT(4)
+
+#define IER_0				0x0C
+
+#define CFG_0				0x10
+#define CFG_HW_ECC_MASK			BIT(31)
+#define CFG_HW_ECC_DISABLE		0
+#define CFG_HW_ECC_ENABLE		BIT(31)
+#define CFG_HW_ECC_SEL_MASK		BIT(30)
+#define CFG_HW_ECC_SEL_HAMMING		0
+#define CFG_HW_ECC_SEL_RS		BIT(30)
+#define CFG_HW_ECC_CORRECTION_MASK	BIT(29)
+#define CFG_HW_ECC_CORRECTION_DISABLE	0
+#define CFG_HW_ECC_CORRECTION_ENABLE	BIT(29)
+#define CFG_PIPELINE_EN_MASK		BIT(28)
+#define CFG_PIPELINE_EN_DISABLE		0
+#define CFG_PIPELINE_EN_ENABLE		BIT(28)
+#define CFG_ECC_EN_TAG_MASK		BIT(27)
+#define CFG_ECC_EN_TAG_DISABLE		0
+#define CFG_ECC_EN_TAG_ENABLE		BIT(27)
+#define CFG_TVALUE_MASK			(3 << 24)
+enum {
+	CFG_TVAL4 = 0 << 24,
+	CFG_TVAL6 = 1 << 24,
+	CFG_TVAL8 = 2 << 24
+};
+
+#define CFG_SKIP_SPARE_MASK		BIT(23)
+#define CFG_SKIP_SPARE_DISABLE		0
+#define CFG_SKIP_SPARE_ENABLE		BIT(23)
+#define CFG_COM_BSY_MASK		BIT(22)
+#define CFG_COM_BSY_DISABLE		0
+#define CFG_COM_BSY_ENABLE		BIT(22)
+#define CFG_BUS_WIDTH_MASK		BIT(21)
+#define CFG_BUS_WIDTH_8BIT		0
+#define CFG_BUS_WIDTH_16BIT		BIT(21)
+#define CFG_LPDDR1_MODE_MASK		BIT(20)
+#define CFG_LPDDR1_MODE_DISABLE		0
+#define CFG_LPDDR1_MODE_ENABLE		BIT(20)
+#define CFG_EDO_MODE_MASK		BIT(19)
+#define CFG_EDO_MODE_DISABLE		0
+#define CFG_EDO_MODE_ENABLE		BIT(19)
+#define CFG_PAGE_SIZE_SEL_MASK		(7 << 16)
+enum {
+	CFG_PAGE_SIZE_256	= 0 << 16,
+	CFG_PAGE_SIZE_512	= 1 << 16,
+	CFG_PAGE_SIZE_1024	= 2 << 16,
+	CFG_PAGE_SIZE_2048	= 3 << 16,
+	CFG_PAGE_SIZE_4096	= 4 << 16
+};
+
+#define CFG_SKIP_SPARE_SEL_MASK		(3 << 14)
+enum {
+	CFG_SKIP_SPARE_SEL_4	= 0 << 14,
+	CFG_SKIP_SPARE_SEL_8	= 1 << 14,
+	CFG_SKIP_SPARE_SEL_12	= 2 << 14,
+	CFG_SKIP_SPARE_SEL_16	= 3 << 14
+};
+
+#define CFG_TAG_BYTE_SIZE_MASK	0x1FF
+
+#define TIMING_0			0x14
+#define TIMING_TRP_RESP_CNT_SHIFT	28
+#define TIMING_TRP_RESP_CNT_MASK	(0xf << TIMING_TRP_RESP_CNT_SHIFT)
+#define TIMING_TWB_CNT_SHIFT		24
+#define TIMING_TWB_CNT_MASK		(0xf << TIMING_TWB_CNT_SHIFT)
+#define TIMING_TCR_TAR_TRR_CNT_SHIFT	20
+#define TIMING_TCR_TAR_TRR_CNT_MASK	(0xf << TIMING_TCR_TAR_TRR_CNT_SHIFT)
+#define TIMING_TWHR_CNT_SHIFT		16
+#define TIMING_TWHR_CNT_MASK		(0xf << TIMING_TWHR_CNT_SHIFT)
+#define TIMING_TCS_CNT_SHIFT		14
+#define TIMING_TCS_CNT_MASK		(3 << TIMING_TCS_CNT_SHIFT)
+#define TIMING_TWH_CNT_SHIFT		12
+#define TIMING_TWH_CNT_MASK		(3 << TIMING_TWH_CNT_SHIFT)
+#define TIMING_TWP_CNT_SHIFT		8
+#define TIMING_TWP_CNT_MASK		(0xf << TIMING_TWP_CNT_SHIFT)
+#define TIMING_TRH_CNT_SHIFT		4
+#define TIMING_TRH_CNT_MASK		(3 << TIMING_TRH_CNT_SHIFT)
+#define TIMING_TRP_CNT_SHIFT		0
+#define TIMING_TRP_CNT_MASK		(0xf << TIMING_TRP_CNT_SHIFT)
+
+#define RESP_0				0x18
+
+#define TIMING2_0			0x1C
+#define TIMING2_TADL_CNT_SHIFT		0
+#define TIMING2_TADL_CNT_MASK		(0xf << TIMING2_TADL_CNT_SHIFT)
+
+#define CMD_REG1_0			0x20
+#define CMD_REG2_0			0x24
+#define ADDR_REG1_0			0x28
+#define ADDR_REG2_0			0x2C
+
+#define DMA_MST_CTRL_0			0x30
+#define DMA_MST_CTRL_GO_MASK		BIT(31)
+#define DMA_MST_CTRL_GO_DISABLE		0
+#define DMA_MST_CTRL_GO_ENABLE		BIT(31)
+#define DMA_MST_CTRL_DIR_MASK		BIT(30)
+#define DMA_MST_CTRL_DIR_READ		0
+#define DMA_MST_CTRL_DIR_WRITE		BIT(30)
+#define DMA_MST_CTRL_PERF_EN_MASK	BIT(29)
+#define DMA_MST_CTRL_PERF_EN_DISABLE	0
+#define DMA_MST_CTRL_PERF_EN_ENABLE	BIT(29)
+#define DMA_MST_CTRL_REUSE_BUFFER_MASK	BIT(27)
+#define DMA_MST_CTRL_REUSE_BUFFER_DISABLE	0
+#define DMA_MST_CTRL_REUSE_BUFFER_ENABLE	BIT(27)
+#define DMA_MST_CTRL_BURST_SIZE_SHIFT	24
+#define DMA_MST_CTRL_BURST_SIZE_MASK	(7 << DMA_MST_CTRL_BURST_SIZE_SHIFT)
+enum {
+	DMA_MST_CTRL_BURST_1WORDS	= 2 << DMA_MST_CTRL_BURST_SIZE_SHIFT,
+	DMA_MST_CTRL_BURST_4WORDS	= 3 << DMA_MST_CTRL_BURST_SIZE_SHIFT,
+	DMA_MST_CTRL_BURST_8WORDS	= 4 << DMA_MST_CTRL_BURST_SIZE_SHIFT,
+	DMA_MST_CTRL_BURST_16WORDS	= 5 << DMA_MST_CTRL_BURST_SIZE_SHIFT
+};
+
+#define DMA_MST_CTRL_IS_DMA_DONE	BIT(20)
+#define DMA_MST_CTRL_EN_A_MASK		BIT(2)
+#define DMA_MST_CTRL_EN_A_DISABLE	0
+#define DMA_MST_CTRL_EN_A_ENABLE	BIT(2)
+#define DMA_MST_CTRL_EN_B_MASK		BIT(1)
+#define DMA_MST_CTRL_EN_B_DISABLE	0
+#define DMA_MST_CTRL_EN_B_ENABLE	BIT(1)
+
+#define DMA_CFG_A_0			0x34
+#define DMA_CFG_B_0			0x38
+#define FIFO_CTRL_0			0x3C
+#define DATA_BLOCK_PTR_0		0x40
+#define TAG_PTR_0			0x44
+#define ECC_PTR_0			0x48
+
+#define DEC_STATUS_0			0x4C
+#define DEC_STATUS_A_ECC_FAIL		BIT(1)
+#define DEC_STATUS_B_ECC_FAIL		BIT(0)
+
+#define BCH_CONFIG_0			0xCC
+#define BCH_CONFIG_BCH_TVALUE_SHIFT	4
+#define BCH_CONFIG_BCH_TVALUE_MASK	(3 << BCH_CONFIG_BCH_TVALUE_SHIFT)
+enum {
+	BCH_CONFIG_BCH_TVAL4	= 0 << BCH_CONFIG_BCH_TVALUE_SHIFT,
+	BCH_CONFIG_BCH_TVAL8	= 1 << BCH_CONFIG_BCH_TVALUE_SHIFT,
+	BCH_CONFIG_BCH_TVAL14	= 2 << BCH_CONFIG_BCH_TVALUE_SHIFT,
+	BCH_CONFIG_BCH_TVAL16	= 3 << BCH_CONFIG_BCH_TVALUE_SHIFT
+};
+
+#define BCH_CONFIG_BCH_ECC_MASK		BIT(0)
+#define BCH_CONFIG_BCH_ECC_DISABLE	0
+#define BCH_CONFIG_BCH_ECC_ENABLE	BIT(0)
+
+#define BCH_DEC_RESULT_0			0xD0
+#define BCH_DEC_RESULT_CORRFAIL_ERR_MASK	BIT(8)
+#define BCH_DEC_RESULT_PAGE_COUNT_MASK		0xFF
+
+#define BCH_DEC_STATUS_BUF_0			0xD4
+#define BCH_DEC_STATUS_FAIL_SEC_FLAG_MASK	0xFF000000
+#define BCH_DEC_STATUS_CORR_SEC_FLAG_MASK	0x00FF0000
+#define BCH_DEC_STATUS_FAIL_TAG_MASK		BIT(14)
+#define BCH_DEC_STATUS_CORR_TAG_MASK		BIT(13)
+#define BCH_DEC_STATUS_MAX_CORR_CNT_MASK	(0x1f << 8)
+#define BCH_DEC_STATUS_PAGE_NUMBER_MASK		0xFF
+
+/* Cortina NAND definition */
+#define BCH_GF_PARAM_M		14
+#define BCH_DATA_UNIT		1024
+#define FLASH_SHORT_DELAY	100
+#define FLASH_LONG_DELAY	1000
+#define FLASH_WIDTH		16
+
+/* Bit field in FLAS_TYPE */
+#define FLASH_PIN		BIT(15)
+#define FLASH_TYPE_512		0x4000
+#define FLASH_TYPE_2K		0x5000
+#define FLASH_TYPE_4K		0x6000
+#define FLASH_TYPE_8K		0x7000
+#define FLASH_SIZE_CONFIGURABLEOOB	(0x0 << 9)
+#define FLASH_SIZE_400OOB		(0x1 << 9)
+#define FLASH_SIZE_436OOB		(0x2 << 9)
+#define FLASH_SIZE_640OOB		(0x3 << 9)
+
+/* Bit field in FLASH_STATUS */
+#define NFLASH_READY	BIT(26)
+
+/* Bit field in FLASH_NF_ACCESS */
+#define NFLASH_ENABLE_ALTERNATIVE	BIT(15)
+#define AUTO_RESET			BIT(16)
+#define NFLASH_REG_WIDTH_RESERVED	(0x3 << 10)
+#define NFLASH_REG_WIDTH_32		(0x2 << 10)
+#define NFLASH_REG_WIDTH_16		(0x1 << 10)
+#define NFLASH_REG_WIDTH_8		(0x0 << 10)
+
+/* Bit field in FLASH_NF_COUNT */
+#define REG_CMD_COUNT_EMPTY		0x3
+#define REG_CMD_COUNT_3TOGO		0x2
+#define REG_CMD_COUNT_2TOGO		0x1
+#define REG_CMD_COUNT_1TOGO		0x0
+#define REG_ADDR_COUNT_EMPTY		(0x7 << 4)
+#define REG_ADDR_COUNT_5		(0x4 << 4)
+#define REG_ADDR_COUNT_4		(0x3 << 4)
+#define REG_ADDR_COUNT_3		(0x2 << 4)
+#define REG_ADDR_COUNT_2		(0x1 << 4)
+#define REG_ADDR_COUNT_1		(0x0 << 4)
+#define REG_DATA_COUNT_EMPTY		(0x3fff << 8)
+#define REG_DATA_COUNT_512P_DATA	0x1FF
+#define REG_DATA_COUNT_2kP_DATA		0x7FF
+#define REG_DATA_COUNT_4kP_DATA		0xFFF
+#define REG_DATA_COUNT_DATA_1		0x0
+#define REG_DATA_COUNT_DATA_2		0x1
+#define REG_DATA_COUNT_DATA_3		0x2
+#define REG_DATA_COUNT_DATA_4		0x3
+#define REG_DATA_COUNT_DATA_5		0x4
+#define REG_DATA_COUNT_DATA_6		0x5
+#define REG_DATA_COUNT_DATA_7		0x6
+#define REG_DATA_COUNT_DATA_8		0x7
+#define REG_OOB_COUNT_EMPTY		(0x3ff << 8)
+
+/* Bit field in FLASH_NF_COMMAND */
+
+/* Bit field in FLASH_FLASH_ACCESS_START */
+#define NFLASH_GO		BIT(0)
+#define NFLASH_FIFO_REQ		BIT(2)
+#define NFLASH_RD		BIT(13)
+#define NFLASH_WT		(BIT(12) | BIT(13))
+
+/* Bit field in FLASH_NF_ECC_RESET */
+#define RESET_NFLASH_RESET	BIT(2)
+#define RESET_NFLASH_FIFO	BIT(1)
+#define RESET_NFLASH_ECC	BIT(0)
+#define ECC_RESET_ALL	RESET_NFLASH_RESET | RESET_NFLASH_FIFO | RESET_NFLASH_ECC
+
+/* Bit field in FLASH_NF_ECC_CONTROL */
+#define ENABLE_ECC_GENERATION		BIT(8)
+
+/* Flash FIFO control */
+#define FIFO_READ	2
+#define FIFO_WRITE	3
+
+/* BCH ECC field definition */
+#define BCH_COMPARE				BIT(0)
+#define	BCH_ENABLE			BIT(8)
+#define	BCH_DECODE			BIT(1)
+#define BCH_DECO_DONE			BIT(30)
+#define BCH_GEN_DONE			BIT(31)
+#define	BCH_UNCORRECTABLE       0x3
+#define	BCH_CORRECTABLE_ERR     0x2
+#define	BCH_NO_ERR		0x1
+#define	BCH_BUSY		    0x0
+#define BCH_ERR_MASK			0x3
+#define BCH_ERR_CAP_8			(0x0 << 9)
+#define BCH_ERR_CAP_16			(0x1 << 9)
+#define BCH_ERR_CAP_24			(0x2 << 9)
+#define BCH_ERR_CAP_40			(0x3 << 9)
+
+#define BCH_GF_PARAM_M		14
+#define BCH_DATA_UNIT		1024
+
+struct nand_ctlr {
+#if 0
+	u32	command;	/* offset 00h */
+	u32	status;		/* offset 04h */
+	u32	isr;		/* offset 08h */
+	u32	ier;		/* offset 0Ch */
+	u32	config;		/* offset 10h */
+	u32	timing;		/* offset 14h */
+	u32	resp;		/* offset 18h */
+	u32	timing2;	/* offset 1Ch */
+	u32	cmd_reg1;	/* offset 20h */
+	u32	cmd_reg2;	/* offset 24h */
+	u32	addr_reg1;	/* offset 28h */
+	u32	addr_reg2;	/* offset 2Ch */
+	u32	dma_mst_ctrl;	/* offset 30h */
+	u32	dma_cfg_a;	/* offset 34h */
+	u32	dma_cfg_b;	/* offset 38h */
+	u32	fifo_ctrl;	/* offset 3Ch */
+	u32	data_block_ptr;	/* offset 40h */
+	u32	tag_ptr;	/* offset 44h */
+	u32	resv1;		/* offset 48h */
+	u32	dec_status;	/* offset 4Ch */
+	u32	hwstatus_cmd;	/* offset 50h */
+	u32	hwstatus_mask;	/* offset 54h */
+	u32	resv2[29];
+	u32	bch_config;	/* offset CCh */
+	u32	bch_dec_result;	/* offset D0h */
+	u32	bch_dec_status_buf;	/* offset D4h */
+#endif
+
+	/* Cortina NAND controller register */
+	u32 flash_id;		     // offset 0x000
+	u32 flash_timeout;		// offset 0x004
+	u32 flash_status;		 // offset 0x008
+	u32 flash_type;		   // offset 0x00c
+	u32 flash_flash_access_start;     // offset 0x010
+	u32 flash_flash_interrupt;	// offset 0x014
+	u32 flash_flash_mask;	     // offset 0x018
+	u32 flash_fifo_control;	   // offset 0x01c
+	u32 flash_fifo_status;	    // offset 0x020
+	u32 flash_fifo_address;	   // offset 0x024
+	u32 flash_fifo_match_address;     // offset 0x028
+	u32 flash_fifo_data;	      // offset 0x02c
+	u32 flash_sf_access;	      // offset 0x030
+	u32 flash_sf_ext_access;	  // offset 0x034
+	u32 flash_sf_address;	     // offset 0x038
+	u32 flash_sf_data;		// offset 0x03c
+	u32 flash_sf_timing;	      // offset 0x040
+	u32 empty[3];
+	u32 flash_pf_access;	      // offset 0x050
+	u32 flash_pf_timing;	      // offset 0x054
+	u32 empty1[2];
+	u32 flash_nf_access;	      // offset 0x060
+	u32 flash_nf_count;	       // offset 0x064
+	u32 flash_nf_command;	     // offset 0x068
+	u32 flash_nf_address_1;	   // offset 0x06c
+	u32 flash_nf_address_2;	   // offset 0x070
+	u32 flash_nf_data;		// offset 0x074
+	u32 flash_nf_timing;	      // offset 0x078
+	u32 flash_nf_ecc_status;	  // offset 0x07c
+	u32 flash_nf_ecc_control;	 // offset 0x080
+	u32 flash_nf_ecc_oob;	     // offset 0x084
+	u32 flash_nf_ecc_gen0;	    // offset 0x088
+	u32 flash_nf_ecc_gen1;	    // offset 0x08c
+	u32 flash_nf_ecc_gen2;	    // offset 0x090
+	u32 flash_nf_ecc_gen3;	    // offset 0x094
+	u32 flash_nf_ecc_gen4;	    // offset 0x098
+	u32 flash_nf_ecc_gen5;	    // offset 0x09c
+	u32 flash_nf_ecc_gen6;	    // offset 0x0a0
+	u32 flash_nf_ecc_gen7;	    // offset 0x0a4
+	u32 flash_nf_ecc_gen8;	    // offset 0x0a8
+	u32 flash_nf_ecc_gen9;	    // offset 0x0ac
+	u32 flash_nf_ecc_gen10;	   // offset 0x0b0
+	u32 flash_nf_ecc_gen11;	   // offset 0x0b4
+	u32 flash_nf_ecc_gen12;	   // offset 0x0b8
+	u32 flash_nf_ecc_gen13;	   // offset 0x0bc
+	u32 flash_nf_ecc_gen14;	   // offset 0x0c0
+	u32 flash_nf_ecc_gen15;	   // offset 0x0c4
+	u32 flash_nf_ecc_reset;	   // offset 0x0c8
+	u32 flash_nf_bch_control;	 // offset 0x0cc
+	u32 flash_nf_bch_status;	  // offset 0x0d0
+	u32 flash_nf_bch_error_loc01;     // offset 0x0d4
+	u32 flash_nf_bch_error_loc23;     // offset 0x0d8
+	u32 flash_nf_bch_error_loc45;     // offset 0x0dc
+	u32 flash_nf_bch_error_loc67;     // offset 0x0e0
+	u32 flash_nf_bch_error_loc89;     // offset 0x0e4
+	u32 flash_nf_bch_error_loc1011;   // offset 0x0e8
+	u32 flash_nf_bch_error_loc1213;   // offset 0x0ec
+	u32 flash_nf_bch_error_loc1415;   // offset 0x0f0
+	u32 flash_nf_bch_error_loc1617;   // offset 0x0f4
+	u32 flash_nf_bch_error_loc1819;   // offset 0x0f8
+	u32 flash_nf_bch_error_loc2021;   // offset 0x0fc
+	u32 flash_nf_bch_error_loc2223;   // offset 0x100
+	u32 flash_nf_bch_error_loc2425;   // offset 0x104
+	u32 flash_nf_bch_error_loc2627;   // offset 0x108
+	u32 flash_nf_bch_error_loc2829;   // offset 0x10c
+	u32 flash_nf_bch_error_loc3031;   // offset 0x110
+	u32 flash_nf_bch_error_loc3233;   // offset 0x114
+	u32 flash_nf_bch_error_loc3435;   // offset 0x118
+	u32 flash_nf_bch_error_loc3637;   // offset 0x11c
+	u32 flash_nf_bch_error_loc3839;   // offset 0x120
+	u32 flash_nf_bch_oob0;	    // offset 0x124
+	u32 flash_nf_bch_oob1;	    // offset 0x128
+	u32 flash_nf_bch_oob2;	    // offset 0x12c
+	u32 flash_nf_bch_oob3;	    // offset 0x130
+	u32 flash_nf_bch_oob4;	    // offset 0x134
+	u32 flash_nf_bch_oob5;	    // offset 0x138
+	u32 flash_nf_bch_oob6;	    // offset 0x13c
+	u32 flash_nf_bch_oob7;	    // offset 0x140
+	u32 flash_nf_bch_oob8;	    // offset 0x144
+	u32 flash_nf_bch_oob9;	    // offset 0x148
+	u32 flash_nf_bch_oob10;	   // offset 0x14c
+	u32 flash_nf_bch_oob11;	   // offset 0x150
+	u32 flash_nf_bch_oob12;	   // offset 0x154
+	u32 flash_nf_bch_oob13;	   // offset 0x158
+	u32 flash_nf_bch_oob14;	   // offset 0x15c
+	u32 flash_nf_bch_oob15;	   // offset 0x160
+	u32 flash_nf_bch_oob16;	   // offset 0x164
+	u32 flash_nf_bch_oob17;	   // offset 0x168
+	u32 flash_nf_bch_gen0_0;	  // offset 0x16c
+	u32 flash_nf_bch_gen0_1;	  // offset 0x170
+	u32 flash_nf_bch_gen0_2;	  // offset 0x174
+	u32 flash_nf_bch_gen0_3;	  // offset 0x178
+	u32 flash_nf_bch_gen0_4;	  // offset 0x17c
+	u32 flash_nf_bch_gen0_5;	  // offset 0x180
+	u32 flash_nf_bch_gen0_6;	  // offset 0x184
+	u32 flash_nf_bch_gen0_7;	  // offset 0x188
+	u32 flash_nf_bch_gen0_8;	  // offset 0x18c
+	u32 flash_nf_bch_gen0_9;	  // offset 0x190
+	u32 flash_nf_bch_gen0_10;	 // offset 0x194
+	u32 flash_nf_bch_gen0_11;	 // offset 0x198
+	u32 flash_nf_bch_gen0_12;	 // offset 0x19c
+	u32 flash_nf_bch_gen0_13;	 // offset 0x1a0
+	u32 flash_nf_bch_gen0_14;	 // offset 0x1a4
+	u32 flash_nf_bch_gen0_15;	 // offset 0x1a8
+	u32 flash_nf_bch_gen0_16;	 // offset 0x1ac
+	u32 flash_nf_bch_gen0_17;	 // offset 0x1b0
+	u32 flash_nf_bch_gen1_0;	  // offset 0x1b4
+	u32 flash_nf_bch_gen1_1;	  // offset 0x1b8
+	u32 flash_nf_bch_gen1_2;	  // offset 0x1bc
+	u32 flash_nf_bch_gen1_3;	  // offset 0x1c0
+	u32 flash_nf_bch_gen1_4;	  // offset 0x1c4
+	u32 flash_nf_bch_gen1_5;	  // offset 0x1c8
+	u32 flash_nf_bch_gen1_6;	  // offset 0x1cc
+	u32 flash_nf_bch_gen1_7;	  // offset 0x1d0
+	u32 flash_nf_bch_gen1_8;	  // offset 0x1d4
+	u32 flash_nf_bch_gen1_9;	  // offset 0x1d8
+	u32 flash_nf_bch_gen1_10;	 // offset 0x1dc
+	u32 flash_nf_bch_gen1_11;	 // offset 0x1e0
+	u32 flash_nf_bch_gen1_12;	 // offset 0x1e4
+	u32 flash_nf_bch_gen1_13;	 // offset 0x1e8
+	u32 flash_nf_bch_gen1_14;	 // offset 0x1ec
+	u32 flash_nf_bch_gen1_15;	 // offset 0x1f0
+	u32 flash_nf_bch_gen1_16;	 // offset 0x1f4
+	u32 flash_nf_bch_gen1_17;	 // offset 0x1f8
+	u32 flash_nf_bch_gen2_0;	  // offset 0x1fc
+	u32 flash_nf_bch_gen2_1;	  // offset 0x200
+	u32 flash_nf_bch_gen2_2;	  // offset 0x204
+	u32 flash_nf_bch_gen2_3;	  // offset 0x208
+	u32 flash_nf_bch_gen2_4;	  // offset 0x20c
+	u32 flash_nf_bch_gen2_5;	  // offset 0x210
+	u32 flash_nf_bch_gen2_6;	  // offset 0x214
+	u32 flash_nf_bch_gen2_7;	  // offset 0x218
+	u32 flash_nf_bch_gen2_8;	  // offset 0x21c
+	u32 flash_nf_bch_gen2_9;	  // offset 0x220
+	u32 flash_nf_bch_gen2_10;	 // offset 0x224
+	u32 flash_nf_bch_gen2_11;	 // offset 0x228
+	u32 flash_nf_bch_gen2_12;	 // offset 0x22c
+	u32 flash_nf_bch_gen2_13;	 // offset 0x230
+	u32 flash_nf_bch_gen2_14;	 // offset 0x234
+	u32 flash_nf_bch_gen2_15;	 // offset 0x238
+	u32 flash_nf_bch_gen2_16;	 // offset 0x23c
+	u32 flash_nf_bch_gen2_17;	 // offset 0x240
+	u32 flash_nf_bch_gen3_0;	  // offset 0x244
+	u32 flash_nf_bch_gen3_1;	  // offset 0x248
+	u32 flash_nf_bch_gen3_2;	  // offset 0x24c
+	u32 flash_nf_bch_gen3_3;	  // offset 0x250
+	u32 flash_nf_bch_gen3_4;	  // offset 0x254
+	u32 flash_nf_bch_gen3_5;	  // offset 0x258
+	u32 flash_nf_bch_gen3_6;	  // offset 0x25c
+	u32 flash_nf_bch_gen3_7;	  // offset 0x260
+	u32 flash_nf_bch_gen3_8;	  // offset 0x264
+	u32 flash_nf_bch_gen3_9;	  // offset 0x268
+	u32 flash_nf_bch_gen3_10;	 // offset 0x26c
+	u32 flash_nf_bch_gen3_11;	 // offset 0x270
+	u32 flash_nf_bch_gen3_12;	 // offset 0x274
+	u32 flash_nf_bch_gen3_13;	 // offset 0x278
+	u32 flash_nf_bch_gen3_14;	 // offset 0x27c
+	u32 flash_nf_bch_gen3_15;	 // offset 0x280
+	u32 flash_nf_bch_gen3_16;	 // offset 0x284
+	u32 flash_nf_bch_gen3_17;	 // offset 0x288
+	u32 flash_nf_bch_gen4_0;	  // offset 0x28c
+	u32 flash_nf_bch_gen4_1;	  // offset 0x290
+	u32 flash_nf_bch_gen4_2;	  // offset 0x294
+	u32 flash_nf_bch_gen4_3;	  // offset 0x298
+	u32 flash_nf_bch_gen4_4;	  // offset 0x29c
+	u32 flash_nf_bch_gen4_5;	  // offset 0x2a0
+	u32 flash_nf_bch_gen4_6;	  // offset 0x2a4
+	u32 flash_nf_bch_gen4_7;	  // offset 0x2a8
+	u32 flash_nf_bch_gen4_8;	  // offset 0x2ac
+	u32 flash_nf_bch_gen4_9;	  // offset 0x2b0
+	u32 flash_nf_bch_gen4_10;	 // offset 0x2b4
+	u32 flash_nf_bch_gen4_11;	 // offset 0x2b8
+	u32 flash_nf_bch_gen4_12;	 // offset 0x2bc
+	u32 flash_nf_bch_gen4_13;	 // offset 0x2c0
+	u32 flash_nf_bch_gen4_14;	 // offset 0x2c4
+	u32 flash_nf_bch_gen4_15;	 // offset 0x2c8
+	u32 flash_nf_bch_gen4_16;	 // offset 0x2cc
+	u32 flash_nf_bch_gen4_17;	 // offset 0x2d0
+	u32 flash_nf_bch_gen5_0;	 // offset 0x2d4
+	u32 flash_nf_bch_gen5_1;	  // offset 0x2d8
+	u32 flash_nf_bch_gen5_2;	  // offset 0x2dc
+	u32 flash_nf_bch_gen5_3;	  // offset 0x2e0
+	u32 flash_nf_bch_gen5_4;	  // offset 0x2e4
+	u32 flash_nf_bch_gen5_5;	  // offset 0x2e8
+	u32 flash_nf_bch_gen5_6;	  // offset 0x2ec
+	u32 flash_nf_bch_gen5_7;	  // offset 0x2f0
+	u32 flash_nf_bch_gen5_8;	  // offset 0x2f4
+	u32 flash_nf_bch_gen5_9;	  // offset 0x2f8
+	u32 flash_nf_bch_gen5_10;	 // offset 0x2fc
+	u32 flash_nf_bch_gen5_11;	 // offset 0x300
+	u32 flash_nf_bch_gen5_12;	 // offset 0x304
+	u32 flash_nf_bch_gen5_13;	 // offset 0x308
+	u32 flash_nf_bch_gen5_14;	 // offset 0x30c
+	u32 flash_nf_bch_gen5_15;	 // offset 0x310
+	u32 flash_nf_bch_gen5_16;	 // offset 0x314
+	u32 flash_nf_bch_gen5_17;	 // offset 0x318
+	u32 flash_nf_bch_gen6_0;	 // offset 0x31c
+	u32 flash_nf_bch_gen6_1;	  // offset 0x320
+	u32 flash_nf_bch_gen6_2;	  // offset 0x324
+	u32 flash_nf_bch_gen6_3;	  // offset 0x328
+	u32 flash_nf_bch_gen6_4;	  // offset 0x32c
+	u32 flash_nf_bch_gen6_5;	  // offset 0x330
+	u32 flash_nf_bch_gen6_6;	  // offset 0x334
+	u32 flash_nf_bch_gen6_7;	  // offset 0x338
+	u32 flash_nf_bch_gen6_8;	  // offset 0x33c
+	u32 flash_nf_bch_gen6_9;	  // offset 0x340
+	u32 flash_nf_bch_gen6_10;	 // offset 0x344
+	u32 flash_nf_bch_gen6_11;	 // offset 0x348
+	u32 flash_nf_bch_gen6_12;	 // offset 0x34c
+	u32 flash_nf_bch_gen6_13;	 // offset 0x350
+	u32 flash_nf_bch_gen6_14;	 // offset 0x354
+	u32 flash_nf_bch_gen6_15;	 // offset 0x358
+	u32 flash_nf_bch_gen6_16;	 // offset 0x35c
+	u32 flash_nf_bch_gen6_17;	 // offset 0x360
+	u32 flash_nf_bch_gen7_0;	  // offset 0x364
+	u32 flash_nf_bch_gen7_1;	  // offset 0x368
+	u32 flash_nf_bch_gen7_2;	  // offset 0x36c
+	u32 flash_nf_bch_gen7_3;	  // offset 0x370
+	u32 flash_nf_bch_gen7_4;	  // offset 0x374
+	u32 flash_nf_bch_gen7_5;	  // offset 0x378
+	u32 flash_nf_bch_gen7_6;	  // offset 0x37c
+	u32 flash_nf_bch_gen7_7;	  // offset 0x380
+	u32 flash_nf_bch_gen7_8;	  // offset 0x384
+	u32 flash_nf_bch_gen7_9;	  // offset 0x388
+	u32 flash_nf_bch_gen7_10;	 // offset 0x38c
+	u32 flash_nf_bch_gen7_11;	 // offset 0x390
+	u32 flash_nf_bch_gen7_12;	 // offset 0x394
+	u32 flash_nf_bch_gen7_13;	 // offset 0x398
+	u32 flash_nf_bch_gen7_14;	 // offset 0x39c
+	u32 flash_nf_bch_gen7_15;	 // offset 0x3a0
+	u32 flash_nf_bch_gen7_16;	 // offset 0x3a4
+	u32 flash_nf_bch_gen7_17;	 // offset 0x3a8
+};
+
+/* Definition for DMA bitfield */
+#define TX_DMA_ENABLE	BIT(0)
+#define RX_DMA_ENABLE	BIT(0)
+#define DMA_CHECK_OWNER	BIT(1)
+#define OWN_DMA			0
+#define OWN_CPU			1
+
+#define CA_DMA_DEPTH	3
+#define CA_DMA_DESC_NUM	BIT(CA_DMA_DEPTH)
+#define CA_DMA_Q_PTR_MASK	0x1fff
+
+struct dma_q_base_depth_t {
+	u32 depth		:  4 ; /* bits 3:0 */
+	u32 base		 : 28 ; /* bits 31:4 */
+};
+
+struct tx_descriptor_t {
+	unsigned int buf_adr;			/* Buff addr */
+	unsigned int buf_adr_hi    :  8 ; /* bits 7:0 */
+	unsigned int buf_len       :  16 ;  /* bits 23:8 */
+	unsigned int sgm	       :  1 ;  /* bits 24 */
+	unsigned int rsrvd	 :  6 ;  /* bits 30:25 */
+	unsigned int own	   :  1 ;  /* bits 31:31 */
+};
+
+struct rx_descriptor_t {
+	unsigned int buf_adr;			/* Buff addr */
+	unsigned int buf_adr_hi    :  8 ; /* bits 7:0 */
+	unsigned int buf_len       : 16 ;  /* bits 23:8 */
+	unsigned int rsrvd	 :  7 ;  /* bits 30:24 */
+	unsigned int own	   :  1 ;  /* bits 31:31 */
+};
+
+struct dma_global {
+	u32 dma_glb_dma_lso_ctrl;
+	u32 dma_glb_lso_interrupt;
+	u32 dma_glb_lso_intenable;
+	u32 dma_glb_dma_lso_vlan_tag_type0;
+	u32 dma_glb_dma_lso_vlan_tag_type1;
+	u32 dma_glb_dma_lso_axi_user_sel0;
+	u32 dma_glb_axi_user_pat0;
+	u32 dma_glb_axi_user_pat1;
+	u32 dma_glb_axi_user_pat2;
+	u32 dma_glb_axi_user_pat3;
+	u32 dma_glb_fast_reg_pe0;
+	u32 dma_glb_fast_reg_pe1;
+	u32 dma_glb_dma_lso_tx_fdes_addr0;
+	u32 dma_glb_dma_lso_tx_fdes_addr1;
+	u32 dma_glb_dma_lso_tx_cdes_addr0;
+	u32 dma_glb_dma_lso_tx_cdes_addr1;
+	u32 dma_glb_dma_lso_tx_des_word0;
+	u32 dma_glb_dma_lso_tx_des_word1;
+	u32 dma_glb_dma_lso_lso_para_word0;
+	u32 dma_glb_dma_lso_lso_para_word1;
+	u32 dma_glb_dma_lso_debug0;
+	u32 dma_glb_dma_lso_debug1;
+	u32 dma_glb_dma_lso_debug2;
+	u32 dma_glb_dma_lso_spare0;
+	u32 dma_glb_dma_lso_spare1;
+	u32 dma_glb_dma_ssp_rx_ctrl;
+	u32 dma_glb_dma_ssp_tx_ctrl;
+	u32 dma_glb_dma_ssp_axi_user_sel0;
+	u32 dma_glb_dma_ssp_axi_user_sel1;
+	u32 dma_glb_dma_ssp_rx_fdes_addr0;
+	u32 dma_glb_dma_ssp_rx_fdes_addr1;
+	u32 dma_glb_dma_ssp_rx_cdes_addr0;
+	u32 dma_glb_dma_ssp_rx_cdes_addr1;
+	u32 dma_glb_dma_ssp_rx_des_word0;
+	u32 dma_glb_dma_ssp_rx_des_word1;
+	u32 dma_glb_dma_ssp_tx_fdes_addr0;
+	u32 dma_glb_dma_ssp_tx_fdes_addr1;
+	u32 dma_glb_dma_ssp_tx_cdes_addr0;
+	u32 dma_glb_dma_ssp_tx_cdes_addr1;
+	u32 dma_glb_dma_ssp_tx_des_word0;
+	u32 dma_glb_dma_ssp_tx_des_word1;
+	u32 dma_glb_dma_ssp_debug0;
+	u32 dma_glb_dma_ssp_debug1;
+	u32 dma_glb_dma_ssp_debug2;
+	u32 dma_glb_dma_ssp_spare0;
+	u32 dma_glb_dma_ssp_spare1;
+};
+
+struct dma_ssp {
+	u32 dma_q_rxq_control;
+	u32 dma_q_rxq_base_depth;
+	u32 dma_q_rxq_base;
+	u32 dma_q_rxq_wptr;
+	u32 dma_q_rxq_rptr;
+	u32 dma_q_rxq_pktcnt;
+	u32 dma_q_txq_control;
+	u32 dma_q_txq_base_depth;
+	u32 dma_q_txq_base;
+	u32 dma_q_txq_wptr;
+	u32 dma_q_txq_rptr;
+	u32 dma_q_txq_pktcnt;
+	u32 dma_q_rxq_interrupt;
+	u32 dma_q_rxq_intenable;
+	u32 dma_q_txq_interrupt;
+	u32 dma_q_txq_intenable;
+	u32 dma_q_rxq_misc_interrupt;
+	u32 dma_q_rxq_misc_intenable;
+	u32 dma_q_txq_misc_interrupt;
+	u32 dma_q_txq_misc_intenable;
+	u32 dma_q_rxq_coal_interrupt;
+	u32 dma_q_rxq_coal_intenable;
+	u32 dma_q_txq_coal_interrupt;
+	u32 dma_q_txq_coal_intenable;
+	u32 dma_q_rxq_frag_buff_addr0;
+	u32 dma_q_rxq_frag_buff_addr1;
+	u32 dma_q_rxq_frag_buff_size;
+	u32 dma_q_txq_frag_buff_addr0;
+	u32 dma_q_txq_frag_buff_addr1;
+	u32 dma_q_txq_frag_buff_size;
+	u32 dma_q_dma_spare_0;
+	u32 dma_q_dma_spare_1;
+};
diff --git a/include/configs/venus.h b/include/configs/venus.h
index 3f43992..7806cd0 100644
--- a/include/configs/venus.h
+++ b/include/configs/venus.h
@@ -76,7 +76,9 @@
 #define CORTINA_DMA_SSP_BASE            0xf7001a00
 #define CONFIG_SYS_FLASH_BASE           0xe0000000
 
-#ifdef CONFIG_NAND_CORTINA
+//#ifdef CONFIG_NAND_CORTINA
+#ifdef CONFIG_CORTINA_NAND
+	#define CONFIG_SYS_NAND_ONFI_DETECTION
 	#define CONFIG_SYS_MAX_NAND_DEVICE	1
 	#define CONFIG_SYS_NAND_MAX_CHIPS	1
 	#define CONFIG_SYS_NAND_BASE		CONFIG_SYS_FLASH_BASE
-- 
1.8.3.1

