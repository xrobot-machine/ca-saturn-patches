From 74e6eea30afe02c10e5e33b88d7e16a54290ab40 Mon Sep 17 00:00:00 2001
From: Pengpeng Chen <Pengpeng.Chen@cortina-access.com>
Date: Wed, 18 Oct 2017 17:37:59 +0800
Subject: [PATCH 2/4] Saturn_SFU: Update spi-nand driver to support bad block
 handling. 		Add uboot new cmd "spi_nand" to support spinand flash
 chips.

Signed-off-by: Pengpeng Chen <Pengpeng.Chen@cortina-access.com>
Signed-off-by: Pengpeng Chen <pengpeng.chen@cortina-access.com>
---
 common/board_r.c                              |   21 +
 common/cmd_spi_nand.c                         |    5 +-
 configs/cortina_saturn-asic-spinand_defconfig |   10 +-
 drivers/mtd/spi-nand/Kconfig                  |   11 +
 drivers/mtd/spi-nand/Makefile                 |    5 +-
 drivers/mtd/spi-nand/cortina_spi_nand.c       | 1265 +++++++++++++++++++++++++
 drivers/mtd/spi-nand/spi-nand-base.c          |   12 +-
 drivers/mtd/spi-nand/spi-nand-cmd.c           |    8 +-
 include/configs/saturn-asic.h                 |   44 +-
 include/spi-nand.h                            |   13 +
 10 files changed, 1381 insertions(+), 13 deletions(-)
 create mode 100755 drivers/mtd/spi-nand/cortina_spi_nand.c
 mode change 100644 => 100755 drivers/mtd/spi-nand/spi-nand-base.c
 mode change 100644 => 100755 drivers/mtd/spi-nand/spi-nand-cmd.c
 mode change 100644 => 100755 include/spi-nand.h

diff --git a/common/board_r.c b/common/board_r.c
index b059080..bc9f912 100755
--- a/common/board_r.c
+++ b/common/board_r.c
@@ -312,6 +312,23 @@ static int init_serial_flash(void)
 }
 #endif /* CONFIG_MTD_CORTINA_SERIAL_NOR */
 
+#if defined(CONFIG_MTD_CORTINA_SPI_NAND)
+static int init_spinand_flash(void)
+{
+	int 	argc;
+	char 	*argv[5];
+
+	argc = 5;
+	argv[0] = "spi_nand";
+	argv[1] = "probe";
+	argv[2] = "1:1";
+	argv[3] = "0";
+	argv[4] = "0";
+	do_spi_nand_flash(NULL, 0, argc, argv);
+	return 0;
+}
+#endif /* CONFIG_MTD_CORTINA_SPI_NAND */
+
 static int initr_announce(void)
 {
 	debug("Now running in RAM - U-Boot at: %08lx\n", gd->relocaddr);
@@ -798,6 +815,10 @@ init_fnc_t init_sequence_r[] = {
 #if defined(CONFIG_MTD_CORTINA_SERIAL_NOR) || defined(CONFIG_MTD_CORTINA_SERIAL_NAND)
 	init_serial_flash,
 #endif /* CONFIG_MTD_CORTINA_SERIAL_NOR */
+#if defined(CONFIG_MTD_CORTINA_SPI_NAND)
+	init_spinand_flash,
+#endif /* CONFIG_MTD_CORTINA_SPI_NAND */
+
 #ifndef CONFIG_SYS_NO_FLASH
 	initr_flash,
 #endif
diff --git a/common/cmd_spi_nand.c b/common/cmd_spi_nand.c
index 5ce2b45..80e804d 100755
--- a/common/cmd_spi_nand.c
+++ b/common/cmd_spi_nand.c
@@ -66,6 +66,7 @@ static int sf_parse_len_arg(char *arg, ulong *len)
 	return 1;
 }
 
+#ifdef CONFIG_DM_SPI
 struct spi_nand_chip *spi_nand_flash_probe(unsigned int busnum, unsigned int cs,
 		unsigned int max_hz, unsigned int spi_mode)
 {
@@ -79,6 +80,7 @@ struct spi_nand_chip *spi_nand_flash_probe(unsigned int busnum, unsigned int cs,
 		printf("spi_nand_init failed\n");
 		return NULL;
 	}
+
 	return chip;
 }
 
@@ -87,6 +89,7 @@ void spi_nand_flash_free(struct spi_nand_chip *chip)
 	spi_free_slave(chip->spi);
 	spi_nand_release(chip);
 }
+#endif
 
 static int do_spi_nand_flash_probe(int argc, char * const argv[])
 {
@@ -286,7 +289,7 @@ static int do_spi_nand_flash_mark_bad(int argc, char * const argv[])
 	return ret == 0 ? 0 : 1;
 }
 
-static int do_spi_nand_flash(cmd_tbl_t *cmdtp, int flag, int argc,
+int do_spi_nand_flash(cmd_tbl_t *cmdtp, int flag, int argc,
 			char * const argv[])
 {
 	const char *cmd;
diff --git a/configs/cortina_saturn-asic-spinand_defconfig b/configs/cortina_saturn-asic-spinand_defconfig
index 302a158..251839b 100644
--- a/configs/cortina_saturn-asic-spinand_defconfig
+++ b/configs/cortina_saturn-asic-spinand_defconfig
@@ -6,6 +6,10 @@ CONFIG_SYS_LITTLE_ENDIAN=y
 #CONFIG_DEFAULT_DEVICE_TREE="vexpress64"
 CONFIG_SHOW_BOOT_PROGRESS=y
 CONFIG_NET=y
-# CONFIG_MTD_CORTINA_SERIAL_NOR=y
-CONFIG_MTD_CORTINA_SERIAL_NAND=y
-CONFIG_CMD_SF=y
+# CONFIG_MTD_CORTINA_SERIAL_NAND=y
+# CONFIG_CMD_SF=y
+# CONFIG_DM=y
+# CONFIG_DM_SPI=y
+CONFIG_SPI_NAND=y
+CONFIG_MTD_CORTINA_SPI_NAND=y
+CONFIG_CMD_SPI_NAND=y
diff --git a/drivers/mtd/spi-nand/Kconfig b/drivers/mtd/spi-nand/Kconfig
index 0db6e74..ba1f94d 100644
--- a/drivers/mtd/spi-nand/Kconfig
+++ b/drivers/mtd/spi-nand/Kconfig
@@ -1,5 +1,11 @@
 menu "SPI NAND Support"
 
+config SPI_NAND
+	tristate "SPI-NAND device Support"
+	help
+		This is the framework for the SPI NAND which can be used by both generic
+		SPI bus and SPI-NAND specified controllers.
+
 config SPI_NAND_USE_SPI_NOR_RD_PROT
 	bool "Use SPI NOR flash 03h/0bh read protocol"
 	default n
@@ -7,4 +13,9 @@ config SPI_NAND_USE_SPI_NOR_RD_PROT
 		Micron M79A SPI NAND support implement 03h/0Bh command, as is done
 		with SPI NOR for compatibility.
 
+config MTD_CORTINA_SPI_NAND
+	tristate "SPI-NAND Flash device mapped on Cortina SoC Platforms"
+	help
+		Map driver for CORTINA reference board.
+
 endmenu # menu "SPI NAND Support"
diff --git a/drivers/mtd/spi-nand/Makefile b/drivers/mtd/spi-nand/Makefile
index 1303858..cf0d372 100644
--- a/drivers/mtd/spi-nand/Makefile
+++ b/drivers/mtd/spi-nand/Makefile
@@ -1,2 +1,3 @@
-obj-$(CONFIG_SPI_NAND) +=  spi-nand-base.o
-obj-$(CONFIG_SPI_NAND) +=  spi-nand-cmd.o
+obj-$(CONFIG_SPI_NAND) += spi-nand-base.o
+obj-$(CONFIG_SPI_NAND) += spi-nand-cmd.o
+obj-$(CONFIG_MTD_CORTINA_SPI_NAND) += cortina_spi_nand.o
diff --git a/drivers/mtd/spi-nand/cortina_spi_nand.c b/drivers/mtd/spi-nand/cortina_spi_nand.c
new file mode 100755
index 0000000..589fef1
--- /dev/null
+++ b/drivers/mtd/spi-nand/cortina_spi_nand.c
@@ -0,0 +1,1265 @@
+/*
+ * Copyright (c) 2017 Cortina Access. All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are met:
+ *
+ * Redistributions of source code must retain the above copyright notice, this
+ * list of conditions and the following disclaimer.
+ *
+ * Redistributions in binary form must reproduce the above copyright notice,
+ * this list of conditions and the following disclaimer in the documentation
+ * and/or other materials provided with the distribution.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
+ * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE
+ * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
+ */
+#include <common.h>
+#include <asm/io.h>
+#include <malloc.h>
+#include <spi-nand.h>
+#include <spi.h>
+
+#define CFI_MFR_MICRON			0x2C
+#define CFI_MFR_GIGADEVICE		0xC8
+#define CFI_MFR_MACRONIX		0xC2
+#define CFI_MFR_TOSHIBA			0x98
+
+#define SF_AC_OPCODE                	0x00
+#define SF_AC_OPCODE_1_DATA           	0x01
+#define SF_AC_OPCODE_2_DATA           	0x02
+#define SF_AC_OPCODE_3_DATA           	0x03
+#define SF_AC_OPCODE_4_DATA           	0x04
+#define SF_AC_OPCODE_3_ADDR         	0x05
+#define SF_AC_OPCODE_3_ADDR_1_DATA    	0x06
+#define SF_AC_OPCODE_3_ADDR_2_DATA    	0x07
+#define SF_AC_OPCODE_3_ADDR_3_DATA    	0x08
+#define SF_AC_OPCODE_3_ADDR_4_DATA    	0x09
+#define SF_AC_OPCODE_3_ADDR_X_1_DATA   	0x0A
+#define SF_AC_OPCODE_3_ADDR_X_2_DATA   	0x0B
+#define SF_AC_OPCODE_3_ADDR_X_3_DATA   	0x0C
+#define SF_AC_OPCODE_3_ADDR_X_4_DATA   	0x0D
+#define SF_AC_OPCODE_3_ADDR_4X_1_DATA  	0x0E
+#define SF_AC_OPCODE_EXTEND				0x0F
+
+#define SF_ACCESS_MIO_SINGLE	0
+#define SF_ACCESS_MIO_DUAL		1
+#define SF_ACCESS_MIO_QUARD		2
+
+#define SF_START_BIT_ENABLE		0x0002
+#define SF_START_BIT_WRITE		0x200
+#define SFLASH_FORCEBURST		0x2000
+#define SFLASH_FORCETERM		0x1000
+
+/* Command for SPI NAND */
+#define CMD_READ				0x13
+#define CMD_READ_RDM			0x0B
+#define CMD_READ_RDM_X2			0x3B
+#define CMD_READ_RDM_X4			0x6B
+#define CMD_PROG_PAGE_CLRCACHE		0x02
+#define CMD_PROG_PAGE_CLRCACHE_X4		0x32
+#define CMD_PROG_PAGE			0x84
+#define CMD_PROG_PAGE_EXC		0x10
+#define CMD_ERASE_BLK			0xd8
+#define CMD_WR_ENABLE			0x06
+#define CMD_WR_DISABLE			0x04
+#define CMD_READ_ID				0x9f
+#define CMD_RESET				0xff
+#define CMD_READ_REG			0x0f
+#define CMD_WRITE_REG			0x1f
+
+/* feature/ status reg */
+#define REG_BLOCK_LOCK		0xa0
+#define REG_OTP				0xb0
+#define REG_STATUS			0xc0	/* timing */
+
+/* B0 Address description */
+#define PARAM_READ_EN		0x40
+#define ECC_EN				0x10
+
+
+/* status */
+#define STATUS_OIP_MASK			0x01
+#define STATUS_READY			(0 << 0)
+#define STATUS_BUSY				(1 << 0)
+
+#define STATUS_E_FAIL_MASK		0x04
+#define STATUS_E_FAIL			(1 << 2)
+
+#define STATUS_P_FAIL_MASK		0x08
+#define STATUS_P_FAIL			(1 << 3)
+
+#define STATUS_ECC_MASK			0x30
+#define STATUS_ECC_1BIT_CORRECTED	(1 << 4)
+#define STATUS_ECC_ERROR		(2 << 4)
+#define STATUS_ECC_RESERVED		(3 << 4)
+
+/*ECC enable defines*/
+#define OTP_ECC_MASK		0x10
+#define OTP_ECC_OFF			0
+#define OTP_ECC_ON			1
+
+#define ECC_DISABLED
+#define ECC_IN_NAND
+#define ECC_SOFT
+
+/* QE */
+#define OTP_QE_MASK		0x1
+#define OTP_QE_EN		1
+#define OTP_QE_OFF		0
+
+/* block lock */
+#define BL_1_2_LOCKED      0x30
+#define BL_1_4_LOCKED      0x28
+#define BL_1_8_LOCKED      0x20
+#define BL_1_16_LOCKED     0x18
+#define BL_1_32_LOCKED     0x10
+#define BL_1_64_LOCKED     0x08
+
+#define PLANE_SELECT		0x40
+#define PLANE_SELECT_BIT	0x1000
+
+#define SFLASH_STATUS_WEL       0x02
+#define SFLASH_STATUS_WIP       0x01
+#define SFLASH_STATUS_BP		0x1C
+#define SFLASH_STATUS_SRWD      0x80
+
+#define SFLASH_WEL_TIMEOUT		8000
+#define SFLASH_PROGRAM_TIMEOUT	8000
+#define SFLASH_ERASE_TIMEOUT	400000
+#define SFLASH_CMD_TIMEOUT		40
+
+#if 0
+/* If device support ONFI, then it can be omitted in this list.
+ * probe function can read parameters from ONFI.
+ * If device(e.g: GigaDevice) not support ONFI, use have to specify in this list.
+ */
+static const struct spi_device_id snand_ids[] = {
+        /* Macronix */
+        { "Mx35LF1Ge4Ab",  INFO(0xC212, 128 * 1024, 1024, 2048, 64, WRITE_4X, 0, 0) },
+        { "Mx35LF2Ge4Ab",  INFO(0xC222, 128 * 1024, 2048, 2048, 64, WRITE_4X|PLANE_BIT, 0x40, 0x1000) },
+
+		/* Micron */
+		{ "Mt29F1G01Abbfdsf",  INFO(0x2C15, 128 * 1024, 1024, 2048, 128, WRITE_4X, 0, 0) },
+		{ "Mt29F1G01Aaaddh4",  INFO(0x2C12, 128 * 1024, 1024, 2048,  64, WRITE_4X|PLANE_BIT, 0x40, 0x1000) },
+		{ "Mt29F2G01Abagdsf",  INFO(0x2C24, 128 * 1024, 2048, 2048, 128, WRITE_4X|PLANE_BIT, 0x40, 0x1000) },
+
+		/* TOSHIBA */
+		{ "Tc58Cvg2S0Hqaie",  INFO(0x98CD, 256 * 1024, 2048, 4096, 128, 0, 0, 0) },
+
+		/* GigaDevice */
+		{ "Gd5F4Gq4R",  INFO(0xC8C4, 256 * 1024, 2048, 4096, 256, 0, 0, 0) },
+		{ "Gd5F4Gq4U",  INFO(0xC8D4, 256 * 1024, 2048, 4096, 256, 0, 0, 0) },
+
+        { },
+};
+#endif
+
+#define GET_UP8BITS(x)	((x >> 0) & 0xff)
+
+static void write_flash_ctrl_reg(unsigned int ofs, unsigned int data)
+{
+        /* CONFIG_CORTINA_FLASH_CTRL_BASE is defined in the platform's
+         * config header. This address may differ from FLASH_ID in that
+         * the platform may need to use a logical, ATU, virtual tranlated 
+         * address. Therefore, we need to use base + offset addressing 
+         */
+        unsigned int base = CONFIG_CORTINA_FLASH_CTRL_BASE;
+        unsigned int offset = ofs - FLASH_ID;
+        unsigned int * addr;
+        addr = (unsigned int*) (base + offset);
+
+        *addr = data;
+}
+
+static unsigned int read_flash_ctrl_reg(unsigned int ofs)
+{
+        /* CONFIG_CORTINA_FLASH_CTRL_BASE is defined in the platform's
+         * config header. This address may differ from FLASH_ID in that
+         * the platform may need to use a logical, ATU, virtual tranlated 
+         * address. Therefore, we need to use base + offset addressing 
+         */
+        unsigned int base = CONFIG_CORTINA_FLASH_CTRL_BASE;
+        unsigned int offset = ofs - FLASH_ID;
+        unsigned int * addr;
+        addr = (unsigned int*) (base + offset);
+
+        return (*addr);
+}
+
+static int wait_flash_cmd_rdy(int timeout)
+{
+	int tmp;
+	unsigned long timebase;
+
+	timebase = get_timer(0);
+	do {
+		tmp = read_flash_ctrl_reg(FLASH_FLASH_ACCESS_START);
+		if ((tmp & SF_START_BIT_ENABLE) == 0) {
+			return 0;
+		}
+	} while (get_timer(timebase) < timeout);
+	return -1;
+}
+
+/*
+ * spinand_read_status- send command 0xf to the SPI Nand status register
+ * Description:
+ *    After read, write, or erase, the Nand device is expected to set the
+ *    busy status.
+ *    This function is to allow reading the status of the command: read,
+ *    write, and erase.
+ *    Once the status turns to be ready, the other status bits also are
+ *    valid status bits.
+ */
+static int spinand_read_status(uint8_t * status)
+{
+
+	unsigned int reg_data;
+	FLASH_SF_ACCESS_t sf_access;
+	FLASH_SF_EXT_ACCESS_t sf_ext_access;
+	sf_access.wrd = 0;
+	sf_ext_access.wrd = 0;
+
+	/* Get feature use 1 byte address as sub-command.
+	 * We must use extend access code to meet this protocol.
+	 */
+	sf_access.bf.sflashAcCode = SF_AC_OPCODE_EXTEND;
+	write_flash_ctrl_reg(FLASH_SF_ACCESS, sf_access.wrd);
+
+	/* Use command in extend_acc register */
+	sf_ext_access.bf.sflashDirRdCmdEn = 1;
+	sf_ext_access.bf.sflashOpCode = CMD_READ_REG;
+	/* No dummy cnt */
+	sf_ext_access.bf.sflashDummyCount = -1;
+	/* 1 byte address */
+	sf_ext_access.bf.sflashAddrCount = 0;
+	/* 1 byte data */
+	sf_ext_access.bf.sflashDataCount = 0;
+	write_flash_ctrl_reg(FLASH_SF_EXT_ACCESS, sf_ext_access.wrd);
+
+	/* Command to get status */
+	write_flash_ctrl_reg(FLASH_SF_ADDRESS, REG_STATUS);
+
+	/* Issue command */
+	write_flash_ctrl_reg(FLASH_FLASH_ACCESS_START, SF_START_BIT_ENABLE);
+
+	/* Wait command ready */
+	if (wait_flash_cmd_rdy(SFLASH_CMD_TIMEOUT) != 0)
+		return -1;
+
+	/* Read out status */
+	reg_data = read_flash_ctrl_reg(FLASH_SF_DATA);
+	*status = reg_data & 0xFF;
+
+	return 0;
+}
+
+/* wait_till_ready- Check device status
+ * Description:
+ *    Read device status register until timeout or OIP cleared.
+ *
+ */
+#define MAX_WAIT_MS  (10)		/* erase might take 4ms */
+static int wait_till_ready(void)
+{
+	int retval;
+	u8 stat = 0;
+	unsigned long timebase;
+
+	timebase = get_timer(0);
+	do {
+		retval = spinand_read_status(&stat);
+		if (retval < 0)
+			return -1;
+		else if ((stat & (STATUS_E_FAIL_MASK | STATUS_P_FAIL_MASK)))
+			break;
+		else if (!(stat & STATUS_BUSY))
+			break;
+	} while (get_timer(timebase) < MAX_WAIT_MS);
+
+	if (stat & (STATUS_E_FAIL_MASK | STATUS_P_FAIL_MASK)) {
+		debug("Staus[0x%x] error!\n", stat);
+		return -1;
+	}
+
+	if ((stat & STATUS_BUSY) == 0)
+		return 0;
+
+	return -1;
+}
+
+/*
+ * ca_spinand_get_feature_reg - send command 0xf with with address <addr> to get register value
+ * Description:
+ */
+static int ca_spinand_get_feature_reg(struct spi_nand_cmd *cmd)
+{
+	uint8_t addr = cmd->addr[0];
+	u8 *value = cmd->rx_buf;
+	unsigned int reg_data;
+	FLASH_SF_ACCESS_t sf_access;
+	FLASH_SF_EXT_ACCESS_t sf_ext_access;
+
+	sf_access.wrd = 0;
+	sf_ext_access.wrd = 0;
+
+	/* Get feature use 1 byte address as sub-command.
+	 * We must use extend access code to meet this protocol.
+	 */
+	sf_access.bf.sflashAcCode = GET_UP8BITS(SF_AC_OPCODE_EXTEND);
+	write_flash_ctrl_reg(FLASH_SF_ACCESS, sf_access.wrd);
+
+	/* Use command in extend_acc register */
+	sf_ext_access.bf.sflashDirRdCmdEn = 1;
+	sf_ext_access.bf.sflashOpCode = SPINAND_CMD_GET_FEATURE;
+	/* No dummy cnt */
+	sf_ext_access.bf.sflashDummyCount = -1;/* (cmd_cfg->dummy_bytes * 8) - 1; */
+	/* 1 byte address */
+	sf_ext_access.bf.sflashAddrCount = 0;/* cmd_cfg->addr_bytes - 1; */
+	/* 1 byte data */
+	sf_ext_access.bf.sflashDataCount = 0;/* cmd_cfg->data_bits - 1; */
+	write_flash_ctrl_reg(FLASH_SF_EXT_ACCESS, sf_ext_access.wrd);
+
+	/* Command to get status */
+	write_flash_ctrl_reg(FLASH_SF_ADDRESS, addr);
+
+	/* Issue command */
+	write_flash_ctrl_reg(FLASH_FLASH_ACCESS_START, SF_START_BIT_ENABLE);
+
+	/* Wait command ready */
+	if (wait_flash_cmd_rdy(SFLASH_CMD_TIMEOUT) != 0)
+		return -1;
+
+	/* Read out status */
+	reg_data = read_flash_ctrl_reg(FLASH_SF_DATA);
+	*value = reg_data & 0xFF;
+
+	return 0;
+}
+
+/*
+ * ca_spinand_get_status_reg - send command 0xf with with address <addr> to get register value
+ * Description:
+ */
+static int ca_spinand_get_status_reg(uint8_t *value)
+{
+	unsigned int reg_data;
+	FLASH_SF_ACCESS_t sf_access;
+	FLASH_SF_EXT_ACCESS_t sf_ext_access;
+
+	sf_access.wrd = 0;
+	sf_ext_access.wrd = 0;
+
+	/* Get feature use 1 byte address as sub-command.
+	 * We must use extend access code to meet this protocol.
+	 */
+	sf_access.bf.sflashAcCode = GET_UP8BITS(SF_AC_OPCODE_EXTEND);
+	write_flash_ctrl_reg(FLASH_SF_ACCESS, sf_access.wrd);
+
+	/* Use command in extend_acc register */
+	sf_ext_access.bf.sflashDirRdCmdEn = 1;
+	sf_ext_access.bf.sflashOpCode = SPINAND_CMD_GET_FEATURE;
+	/* No dummy cnt */
+	sf_ext_access.bf.sflashDummyCount = -1;
+	/* 1 byte address */
+	sf_ext_access.bf.sflashAddrCount = 0;
+	/* 1 byte data */
+	sf_ext_access.bf.sflashDataCount = 0;
+	write_flash_ctrl_reg(FLASH_SF_EXT_ACCESS, sf_ext_access.wrd);
+
+	/* Command to get status */
+	write_flash_ctrl_reg(FLASH_SF_ADDRESS, REG_STATUS);
+
+	/* Issue command */
+	write_flash_ctrl_reg(FLASH_FLASH_ACCESS_START, SF_START_BIT_ENABLE);
+
+	/* Wait command ready */
+	if (wait_flash_cmd_rdy(SFLASH_CMD_TIMEOUT) != 0)
+		return -1;
+
+	/* Read out status */
+	reg_data = read_flash_ctrl_reg(FLASH_SF_DATA);
+	*value = reg_data & 0xFF;
+
+	return 0;
+}
+
+/*
+ * ca_spinand_set_feature_reg - send command 0x1f with address <addr> to set register value
+ * Description:
+ */
+static int ca_spinand_set_feature_reg(struct spi_nand_cmd *cmd)
+{
+	uint8_t addr = cmd->addr[0];
+	const u8 *value = cmd->tx_buf;
+	FLASH_SF_ACCESS_t sf_access;
+	FLASH_SF_EXT_ACCESS_t sf_ext_access;
+
+	sf_access.wrd = 0;
+	sf_ext_access.wrd = 0;
+
+	/* Set feature use 1 byte address as sub-command.
+	 * We must use extend access code to meet this protocol.
+	 */
+	sf_access.bf.sflashAcCode = GET_UP8BITS(SF_AC_OPCODE_EXTEND);
+	write_flash_ctrl_reg(FLASH_SF_ACCESS, sf_access.wrd);
+
+	/* Use command in extend_acc register */
+	sf_ext_access.bf.sflashDirRdCmdEn = 1;
+	sf_ext_access.bf.sflashOpCode = SPINAND_CMD_SET_FEATURE;
+	/* No dummy cnt */
+	sf_ext_access.bf.sflashDummyCount = -1;/* (cmd_cfg->dummy_bytes * 8) - 1; */
+	/* 1 byte address */
+	sf_ext_access.bf.sflashAddrCount = 0;/* cmd_cfg->addr_bytes - 1; */
+	/* 1 byte data */
+	sf_ext_access.bf.sflashDataCount = 0;/* cmd_cfg->data_bits - 1; */
+	write_flash_ctrl_reg(FLASH_SF_EXT_ACCESS, sf_ext_access.wrd);
+
+	/* Command to get status */
+	write_flash_ctrl_reg(FLASH_SF_ADDRESS, addr);
+
+	/* Data register */
+	write_flash_ctrl_reg(FLASH_SF_DATA, *value);
+
+	/* Issue command */
+	write_flash_ctrl_reg(FLASH_FLASH_ACCESS_START, SF_START_BIT_ENABLE);
+
+	/* Wait command ready */
+	if (wait_flash_cmd_rdy(SFLASH_CMD_TIMEOUT) != 0)
+		return -1;
+
+	return 0;
+}
+
+/*
+ * ca_spinand_write_enable- Enable write operation(erase,program)
+ * Description:
+ *    Enable write operation
+ */
+static int ca_spinand_write_enable(struct spi_nand_cmd *cmd)
+{
+	FLASH_SF_ACCESS_t sf_access;
+
+	sf_access.wrd = 0;
+
+	/* Write enable
+	 * Opcode only protocol
+	 */
+	sf_access.bf.sflashOpCode = SPINAND_CMD_WR_ENABLE;
+	sf_access.bf.sflashAcCode = GET_UP8BITS(SF_AC_OPCODE);
+	write_flash_ctrl_reg(FLASH_SF_ACCESS, sf_access.wrd);
+	write_flash_ctrl_reg(FLASH_FLASH_ACCESS_START, SF_START_BIT_ENABLE);
+
+	/* Wait command ready */
+	if (wait_flash_cmd_rdy(SFLASH_CMD_TIMEOUT) != 0)
+		printk("%s: command timeout!\n", __func__);
+
+	return 0;
+}
+
+/*
+ * ca_spi_nand_reset - Reset SPI Nand
+ * Description:
+ *     Reset: reset SPI Nand device
+ */
+static int ca_spinand_reset(struct spi_nand_cmd *cmd)
+{
+    FLASH_SF_ACCESS_t sf_access;
+
+    sf_access.wrd = 0;
+
+	/* Reset SPI-NAND
+	 * Opcode only protocol
+	 */
+	sf_access.bf.sflashOpCode = SPINAND_CMD_RESET;
+	sf_access.bf.sflashAcCode = GET_UP8BITS(SF_AC_OPCODE);
+
+	write_flash_ctrl_reg(FLASH_SF_ACCESS, sf_access.wrd);
+	write_flash_ctrl_reg(FLASH_FLASH_ACCESS_START, SF_START_BIT_ENABLE);
+
+    /* Wait command ready */
+    if (wait_flash_cmd_rdy(SFLASH_CMD_TIMEOUT) != 0) {
+		printk("%s fail!\n", __func__);
+		return -1;
+    }
+
+    /* elapse 1ms before issuing any other command */
+    udelay(1000);
+
+    if (wait_till_ready())
+		printk("%s wait timeout!\n", __func__);
+
+    return 0;
+}
+
+/*
+ * ca_spinand_read_id- Read SPI Nand ID
+ * Description:
+ *    Read ID: read two ID bytes from the SPI Nand device
+ */
+static int ca_spinand_read_id(struct spi_nand_cmd *cmd)
+{
+	u8 *id = cmd->rx_buf;
+	unsigned int reg_data;
+	FLASH_SF_ACCESS_t sf_access;
+	FLASH_SF_EXT_ACCESS_t sf_ext_access;
+
+	sf_access.wrd = 0;
+
+	/* Read ID
+	 * Micron/Macronix:
+	 *  Opcode -> 8 dummy bits -> MAF_ID => DEV_ID
+	 * GigaDevice:
+	 *  Opcode -> MAF_ID => DEV_ID
+	 */
+	sf_access.bf.sflashAcCode = GET_UP8BITS(SF_AC_OPCODE_EXTEND);
+	write_flash_ctrl_reg(FLASH_SF_ACCESS, sf_access.wrd);
+
+	/* Use command in extend_acc register */
+	sf_ext_access.bf.sflashDirRdCmdEn = 1;
+	sf_ext_access.bf.sflashOpCode = SPINAND_CMD_READ_ID;
+	/* 0 dummy bits */
+	sf_ext_access.bf.sflashDummyCount = -1;/* cmd_cfg->dummy_bytes - 1; */
+	/* 0 address byte */
+	sf_ext_access.bf.sflashAddrCount = -1;/* cmd_cfg->addr_bytes - 1; */
+	/* 3 of data length */
+	sf_ext_access.bf.sflashDataCount = 2;
+	write_flash_ctrl_reg(FLASH_SF_EXT_ACCESS, sf_ext_access.wrd);
+
+	/* Start request */
+	write_flash_ctrl_reg(FLASH_FLASH_ACCESS_START, SF_START_BIT_ENABLE);
+
+	if (wait_flash_cmd_rdy(SFLASH_CMD_TIMEOUT) != 0) {
+		id[0] = id[1] = 0;
+		return -1;
+	}
+
+	reg_data = read_flash_ctrl_reg(FLASH_SF_DATA);
+	printk("SPI_NAND ID: 0x%x\n", reg_data);
+
+	if (id[0] != SPINAND_MFR_GIGADEVICE) {
+		id[0] = (reg_data & 0x0000ff00) >> 8;
+		id[1] = (reg_data & 0x00ff0000) >> 16;
+	} else {
+		id[0] = reg_data & 0x000000ff;
+		id[1] = (reg_data & 0x0000ff00) >> 8;
+	}
+
+	return 0;
+}
+
+static int ca_spinand_read_page_to_cache(struct spi_nand_cmd *cmd)
+{
+	u32 page_id = (u32)(cmd->addr[0] << 16) | (u32)(cmd->addr[1] << 8)
+		| (u32)(cmd->addr[2]);
+	uint8_t status = 0;
+	FLASH_SF_ACCESS_t sf_access;
+	FLASH_SF_EXT_ACCESS_t sf_ext_access;
+
+	sf_access.wrd = 0;
+	sf_ext_access.wrd = 0;
+
+	/* Read to cache
+	 * Opcode -> 24bits offset addr => Get feature ....
+	 * 3 bytes address must rely on extend access mothod
+	 */
+	sf_access.bf.sflashAcCode = GET_UP8BITS(SF_AC_OPCODE_EXTEND);
+	sf_access.bf.sflashMIO = SF_ACCESS_MIO_SINGLE;
+	write_flash_ctrl_reg(FLASH_SF_ACCESS, sf_access.wrd);
+
+	/* Use command in extend_acc register */
+	sf_ext_access.bf.sflashDirRdCmdEn = 1;
+	sf_ext_access.bf.sflashOpCode = SPINAND_CMD_PAGE_READ;
+	/* 0 dummy bits */
+	sf_ext_access.bf.sflashDummyCount = -1;/* (cmd_cfg->dummy_bytes * 8) - 1; */
+	/* 3 byte address */
+	sf_ext_access.bf.sflashAddrCount = 2;/* cmd_cfg->addr_bytes - 1; */
+	/* ECC is handled by device, we just push data  */
+	sf_ext_access.bf.sflashDataCount = -1;/* cmd_cfg->data_bits - 1; */
+	write_flash_ctrl_reg(FLASH_SF_EXT_ACCESS, sf_ext_access.wrd);
+
+	/* Fill address */
+	write_flash_ctrl_reg(FLASH_SF_ADDRESS, page_id);
+
+	write_flash_ctrl_reg(FLASH_FLASH_ACCESS_START, SF_START_BIT_ENABLE);
+
+	/* Wait command ready */
+	if (wait_flash_cmd_rdy(SFLASH_CMD_TIMEOUT) != 0) {
+		printk("%s fail!\n", __func__);
+		return -1;
+	}
+
+	/* 80uS with ECC enabled per Micron datasheet */
+	udelay(10);
+
+	if (wait_till_ready()) {
+		printk("%s wait timeout %d!\n", __func__, page_id);
+		return -1;
+	}
+
+	ca_spinand_get_status_reg(&status);
+	if ((status & STATUS_OIP_MASK) == STATUS_READY) {
+		if ((status & STATUS_ECC_MASK) == STATUS_ECC_ERROR) {
+			printk("ECC error! page:%d\n", page_id);
+			return -1;
+		}
+		if ((status & STATUS_ECC_MASK) == STATUS_ECC_1BIT_CORRECTED)
+			printk("Bit corrected! page:%d\n", page_id);
+	}
+	return 0;
+}
+
+static int ca_spinand_read_cache_x1(struct spi_nand_cmd *cmd)
+{
+	u32 offset = (u32)(cmd->addr[0] << 8) | (u32)(cmd->addr[1]);
+	u8 *buf = cmd->rx_buf;
+	u32 len = cmd->n_rx;
+	unsigned int reg_data = 0;
+	FLASH_SF_ACCESS_t sf_access;
+	FLASH_SF_EXT_ACCESS_t sf_ext_access;
+
+	sf_access.wrd = 0;
+	sf_ext_access.wrd = 0;
+
+	/* Read from cache
+	 * Opcode -> 16bits offset addr -> data
+	 * 2 bytes address must use extend access mothod
+	 */
+	sf_access.bf.sflashAcCode = GET_UP8BITS(SF_AC_OPCODE_EXTEND);
+	sf_access.bf.sflashForceBurst = 1;
+
+	write_flash_ctrl_reg(FLASH_SF_ACCESS, sf_access.wrd);
+
+	/* Use command in extend_acc register */
+	sf_ext_access.bf.sflashDirRdCmdEn = 1;
+	sf_ext_access.bf.sflashOpCode = SPINAND_CMD_READ_FROM_CACHE_FAST;
+	/* 8 dummy bits */
+	sf_ext_access.bf.sflashDummyCount = 7;/* (cmd_cfg->dummy_bytes * 8) - 1; */
+	/* 2 byte address */
+	sf_ext_access.bf.sflashAddrCount = 1;/* cmd_cfg->addr_bytes - 1; */
+	/* 4 bytes in one command request */
+	sf_ext_access.bf.sflashDataCount = 3;/* cmd_cfg->data_bits - 1; */
+	write_flash_ctrl_reg(FLASH_SF_EXT_ACCESS, sf_ext_access.wrd);
+
+	/* Fill address */
+	write_flash_ctrl_reg(FLASH_SF_ADDRESS, offset);
+
+	/* Read out data */
+	while (len >= 4) {
+		/* Start access */
+		write_flash_ctrl_reg(FLASH_FLASH_ACCESS_START, SF_START_BIT_ENABLE);
+
+		/* Wait command ready */
+		if (wait_flash_cmd_rdy(SFLASH_CMD_TIMEOUT) != 0) {
+			printk("%s fail!\n", __func__);
+			return -1;
+		}
+
+		reg_data = read_flash_ctrl_reg(FLASH_SF_DATA);
+		*buf++ = reg_data & 0xFF;
+		*buf++ = (reg_data >> 8) & 0xFF;
+		*buf++ = (reg_data >> 16) & 0xFF;
+		*buf++ = (reg_data >> 24) & 0xFF;
+		len -= 4;
+	}
+
+	if (len > 0) {
+		/* Start access */
+		write_flash_ctrl_reg(FLASH_FLASH_ACCESS_START, SF_START_BIT_ENABLE);
+		/* Wait command ready */
+		if (wait_flash_cmd_rdy(SFLASH_CMD_TIMEOUT) != 0) {
+			printk("%s fail!\n", __func__);
+			return -1;
+		}
+
+		reg_data = read_flash_ctrl_reg(FLASH_SF_DATA);
+	}
+
+	switch (len) {
+	case 3:
+		*buf++ = reg_data & 0xFF;
+		*buf++ = (reg_data >> 8) & 0xFF;
+		*buf++ = (reg_data >> 16) & 0xFF;
+		break;
+	case 2:
+		*buf++ = reg_data & 0xFF;
+		*buf++ = (reg_data >> 8) & 0xFF;
+		break;
+	case 1:
+		*buf++ = reg_data & 0xFF;
+		break;
+	case 0:
+		break;
+	default:
+		printk("%s error length %d!\n", __func__, len);
+	}
+
+	/* Finish burst read  */
+	sf_access.bf.sflashForceBurst = 0;
+	sf_access.bf.sflashForceTerm = 1;
+	write_flash_ctrl_reg(FLASH_SF_ACCESS, sf_access.wrd);
+
+	return 0;
+}
+
+static int ca_spinand_read_cache_x2(struct spi_nand_cmd *cmd)
+{
+	u32 offset = (u32)(cmd->addr[0] << 8) | (u32)(cmd->addr[1]);
+	u8 *buf = cmd->rx_buf;
+	u32 len = cmd->n_rx;
+	unsigned int reg_data = 0;
+	FLASH_SF_ACCESS_t sf_access;
+	FLASH_SF_EXT_ACCESS_t sf_ext_access;
+
+	sf_access.wrd = 0;
+	sf_ext_access.wrd = 0;
+
+	/* Read from cache
+	 * Opcode -> 16bits offset addr -> data
+	 * 2 bytes address must rely on extend access mothod
+	 */
+	sf_access.bf.sflashAcCode = GET_UP8BITS(SF_AC_OPCODE_EXTEND);
+	sf_access.bf.sflashForceBurst = 1;
+	sf_access.bf.sflashMIO = SF_ACCESS_MIO_DUAL;
+	sf_access.bf.sflashMData = 1;
+	write_flash_ctrl_reg(FLASH_SF_ACCESS, sf_access.wrd);
+
+	/* Use command in extend_acc register */
+	sf_ext_access.bf.sflashDirRdCmdEn = 1;
+	sf_ext_access.bf.sflashOpCode = SPINAND_CMD_READ_FROM_CACHE_X2;
+	/* 8 dummy bits */
+	sf_ext_access.bf.sflashDummyCount = 7;/* (cmd_cfg->dummy_bytes * 8) - 1; */
+	/* 2 byte address */
+	sf_ext_access.bf.sflashAddrCount = 1;/* cmd_cfg->addr_bytes - 1; */
+	/* 4 bytes in one command request */
+	sf_ext_access.bf.sflashDataCount = 3;/* cmd_cfg->data_bits - 1; */
+	write_flash_ctrl_reg(FLASH_SF_EXT_ACCESS, sf_ext_access.wrd);
+
+	/* Fill address */
+	write_flash_ctrl_reg(FLASH_SF_ADDRESS, offset);
+
+	/* Read out data */
+	while (len >= 4) {
+		/* Start access */
+		write_flash_ctrl_reg(FLASH_FLASH_ACCESS_START, SF_START_BIT_ENABLE);
+
+		/* Wait command ready */
+		if (wait_flash_cmd_rdy(SFLASH_CMD_TIMEOUT) != 0) {
+			printk("%s fail!\n", __func__);
+			return -1;
+		}
+
+		reg_data = read_flash_ctrl_reg(FLASH_SF_DATA);
+		*buf++ = reg_data & 0xFF;
+		*buf++ = (reg_data >> 8) & 0xFF;
+		*buf++ = (reg_data >> 16) & 0xFF;
+		*buf++ = (reg_data >> 24) & 0xFF;
+		len -= 4;
+	}
+
+	if (len > 0) {
+		/* Start access */
+		write_flash_ctrl_reg(FLASH_FLASH_ACCESS_START, SF_START_BIT_ENABLE);
+		/* Wait command ready */
+		if (wait_flash_cmd_rdy(SFLASH_CMD_TIMEOUT) != 0) {
+			printk("%s fail!\n", __func__);
+			return -1;
+		}
+
+		reg_data = read_flash_ctrl_reg(FLASH_SF_DATA);
+	}
+
+	switch (len) {
+	case 3:
+		*buf++ = reg_data & 0xFF;
+		*buf++ = (reg_data >> 8) & 0xFF;
+		*buf++ = (reg_data >> 16) & 0xFF;
+		break;
+	case 2:
+		*buf++ = reg_data & 0xFF;
+		*buf++ = (reg_data >> 8) & 0xFF;
+		break;
+	case 1:
+		*buf++ = reg_data & 0xFF;
+		break;
+	case 0:
+		break;
+	default:
+		printk("%s error length!\n", __func__);
+	}
+
+	/* Finish burst read  */
+	sf_access.bf.sflashForceBurst = 0;
+	sf_access.bf.sflashForceTerm = 1;
+	write_flash_ctrl_reg(FLASH_SF_ACCESS, sf_access.wrd);
+
+	return 0;
+}
+
+static int ca_spinand_read_cache_x4(struct spi_nand_cmd *cmd)
+{
+	u32 offset = (u32)(cmd->addr[0] << 8) | (u32)(cmd->addr[1]);
+	u8 *buf = cmd->rx_buf;
+	u32 len = cmd->n_rx;
+	unsigned int reg_data = 0;
+	FLASH_SF_ACCESS_t sf_access;
+	FLASH_SF_EXT_ACCESS_t sf_ext_access;
+
+	sf_access.wrd = 0;
+	sf_ext_access.wrd = 0;
+
+	/* Read from cache
+	 * Opcode -> 16bits offset addr -> data
+	 * 2 bytes address must rely on extend access mothod
+	 */
+	sf_access.bf.sflashAcCode = GET_UP8BITS(SF_AC_OPCODE_EXTEND);
+	sf_access.bf.sflashForceBurst = 1;
+	sf_access.bf.sflashMIO = SF_ACCESS_MIO_QUARD;
+	sf_access.bf.sflashMData = 1;
+	write_flash_ctrl_reg(FLASH_SF_ACCESS, sf_access.wrd);
+
+	/* Use command in extend_acc register */
+	sf_ext_access.bf.sflashDirRdCmdEn = 1;
+	sf_ext_access.bf.sflashOpCode = SPINAND_CMD_READ_FROM_CACHE_X4;
+	/* 8 dummy bits */
+	sf_ext_access.bf.sflashDummyCount = 7;/* (cmd_cfg->dummy_bytes * 8) - 1; */
+	/* 2 byte address */
+	sf_ext_access.bf.sflashAddrCount = 1;/* cmd_cfg->addr_bytes - 1; */
+	/* 4 bytes in one command request */
+	sf_ext_access.bf.sflashDataCount = 3;/* cmd_cfg->data_bits - 1; */
+	write_flash_ctrl_reg(FLASH_SF_EXT_ACCESS, sf_ext_access.wrd);
+
+	/* Fill address */
+	write_flash_ctrl_reg(FLASH_SF_ADDRESS, offset);
+
+	/* Read out data */
+	while (len >= 4) {
+		/* Start access */
+		write_flash_ctrl_reg(FLASH_FLASH_ACCESS_START, SF_START_BIT_ENABLE);
+
+		/* Wait command ready */
+		if (wait_flash_cmd_rdy(SFLASH_CMD_TIMEOUT) != 0) {
+			printk("%s fail!\n", __func__);
+			return -1;
+		}
+		reg_data = read_flash_ctrl_reg(FLASH_SF_DATA);
+		*buf++ = reg_data & 0xFF;
+		*buf++ = (reg_data >> 8) & 0xFF;
+		*buf++ = (reg_data >> 16) & 0xFF;
+		*buf++ = (reg_data >> 24) & 0xFF;
+		len -= 4;
+	}
+
+	if (len > 0) {
+		/* Start access */
+		write_flash_ctrl_reg(FLASH_FLASH_ACCESS_START, SF_START_BIT_ENABLE);
+		/* Wait command ready */
+		if (wait_flash_cmd_rdy(SFLASH_CMD_TIMEOUT) != 0) {
+			printk("%s fail!\n", __func__);
+			return -1;
+		}
+
+		reg_data = read_flash_ctrl_reg(FLASH_SF_DATA);
+	}
+
+	switch (len) {
+	case 3:
+		*buf++ = reg_data & 0xFF;
+		*buf++ = (reg_data >> 8) & 0xFF;
+		*buf++ = (reg_data >> 16) & 0xFF;
+		break;
+	case 2:
+		*buf++ = reg_data & 0xFF;
+		*buf++ = (reg_data >> 8) & 0xFF;
+		break;
+	case 1:
+		*buf++ = reg_data & 0xFF;
+		break;
+	case 0:
+		break;
+	default:
+		printk("%s error length!\n", __func__);
+	}
+
+	/* Finish burst read  */
+	sf_access.bf.sflashForceBurst = 0;
+	sf_access.bf.sflashForceTerm = 1;
+	write_flash_ctrl_reg(FLASH_SF_ACCESS, sf_access.wrd);
+
+	return 0;
+}
+
+static int ca_spinand_write_cache_x1(struct spi_nand_cmd *cmd)
+{
+	u32 offset = (u32)(cmd->addr[0] << 8) | (u32)(cmd->addr[1]);
+	u8 *buf = cmd->tx_buf;
+	u32 len = cmd->n_tx;
+	unsigned int reg_data;
+	FLASH_SF_ACCESS_t sf_access;
+	FLASH_SF_EXT_ACCESS_t sf_ext_access;
+	FLASH_FLASH_ACCESS_START_t access_start;
+
+	sf_access.wrd = 0;
+	sf_ext_access.wrd = 0;
+	access_start.wrd = 0;
+
+	/* Write to cache
+	 * Opcode -> 16bits offset addr -> data ....
+	 * 2 bytes address must rely on extend access mothod
+	 */
+	sf_access.bf.sflashAcCode = GET_UP8BITS(SF_AC_OPCODE_EXTEND);
+	sf_access.bf.sflashMIO = SF_ACCESS_MIO_SINGLE;
+	sf_access.bf.sflashMData = 0;
+	sf_access.bf.sflashForceBurst = 1;	/* Burst mode */
+	write_flash_ctrl_reg(FLASH_SF_ACCESS, sf_access.wrd);
+
+	/* Use command in extend_acc register */
+	sf_ext_access.bf.sflashDirRdCmdEn = 1;
+	sf_ext_access.bf.sflashOpCode = SPINAND_CMD_PROG_LOAD;
+	/* 0 dummy bits */
+	sf_ext_access.bf.sflashDummyCount = -1;/* (cmd_cfg->dummy_bytes * 8) - 1; */
+	/* 2 byte address */
+	sf_ext_access.bf.sflashAddrCount = 1;/* cmd_cfg->addr_bytes - 1; */
+	/* ECC is handled by device, we just push data  */
+	sf_ext_access.bf.sflashDataCount = 3;/* cmd_cfg->data_bits - 1; */
+	write_flash_ctrl_reg(FLASH_SF_EXT_ACCESS, sf_ext_access.wrd);
+
+	/* Fill address */
+	write_flash_ctrl_reg(FLASH_SF_ADDRESS, offset);
+
+	access_start.bf.sflashRegReq = 1;
+	access_start.bf.sflashRegCmd = 1;
+	/* Burst mode */
+	while (len > 0) {
+		reg_data = buf[0] | (buf[1] << 8) | (buf[2] << 16) | (buf[3] << 24);
+		write_flash_ctrl_reg(FLASH_SF_DATA, reg_data);
+		write_flash_ctrl_reg(FLASH_FLASH_ACCESS_START, access_start.wrd);
+
+		/* Wait command ready */
+		if (wait_flash_cmd_rdy(SFLASH_CMD_TIMEOUT) != 0) {
+			printk("%s timeout\n", __func__);
+			return -1;
+		}
+
+		len -= 4;
+		buf += 4;
+	}
+
+	sf_access.bf.sflashForceBurst = 0;
+	sf_access.bf.sflashForceTerm = 1;	/* Terminate burst mode */
+	write_flash_ctrl_reg(FLASH_SF_ACCESS, sf_access.wrd);
+
+	return 0;
+}
+
+static int ca_spinand_write_cache_x4(struct spi_nand_cmd *cmd)
+{
+	u32 offset = (u32)(cmd->addr[0] << 8) | (u32)(cmd->addr[1]);
+	u8 *buf = cmd->tx_buf;
+	u32 len = cmd->n_tx;
+	unsigned int reg_data;
+	FLASH_SF_ACCESS_t sf_access;
+	FLASH_SF_EXT_ACCESS_t sf_ext_access;
+	FLASH_FLASH_ACCESS_START_t access_start;
+
+	sf_access.wrd = 0;
+	sf_ext_access.wrd = 0;
+	access_start.wrd = 0;
+
+	/* Write to cache
+	 * Opcode -> 16bits offset addr -> data ....
+	 * 2 bytes address must rely on extend access mothod
+	 */
+	sf_access.bf.sflashAcCode = GET_UP8BITS(SF_AC_OPCODE_EXTEND);
+	sf_access.bf.sflashMIO = SF_ACCESS_MIO_QUARD;
+	sf_access.bf.sflashMData = 1;
+	sf_access.bf.sflashForceBurst = 1;	/* Burst mode */
+	write_flash_ctrl_reg(FLASH_SF_ACCESS, sf_access.wrd);
+
+	/* Use command in extend_acc register */
+	sf_ext_access.bf.sflashDirRdCmdEn = 1;
+	sf_ext_access.bf.sflashOpCode = SPINAND_CMD_PROG_LOAD_X4;
+	/* 0 dummy bits */
+	sf_ext_access.bf.sflashDummyCount = -1;/* (cmd_cfg->dummy_bytes * 8) - 1; */
+	/* 2 byte address */
+	sf_ext_access.bf.sflashAddrCount = 1;/* cmd_cfg->addr_bytes - 1; */
+	/* 4 bytes in one command request */
+	sf_ext_access.bf.sflashDataCount = 3;/* cmd_cfg->data_bits - 1; */
+	write_flash_ctrl_reg(FLASH_SF_EXT_ACCESS, sf_ext_access.wrd);
+
+	/* Fill address */
+	write_flash_ctrl_reg(FLASH_SF_ADDRESS, offset);
+
+	access_start.bf.sflashRegReq = 1;
+	access_start.bf.sflashRegCmd = 1;
+	/* Burst mode */
+	while (len > 0) {
+		reg_data = buf[0] | (buf[1] << 8) | (buf[2] << 16) | (buf[3] << 24);
+		write_flash_ctrl_reg(FLASH_SF_DATA, reg_data);
+		write_flash_ctrl_reg(FLASH_FLASH_ACCESS_START, access_start.wrd);
+
+		/* Wait command ready */
+		if (wait_flash_cmd_rdy(SFLASH_CMD_TIMEOUT) != 0) {
+			printk("%s timeout\n", __func__);
+			return -1;
+		}
+
+		len -= 4;
+		buf += 4;
+	}
+
+	sf_access.bf.sflashForceBurst = 0;
+	sf_access.bf.sflashForceTerm = 1;	/* Terminate burst mode */
+	write_flash_ctrl_reg(FLASH_SF_ACCESS, sf_access.wrd);
+
+	return 0;
+}
+
+static int ca_spinand_program_execute(struct spi_nand_cmd *cmd)
+{
+	u32	offset = (u32)(cmd->addr[0] << 16) | (u32)(cmd->addr[1] << 8)
+		| (u32)(cmd->addr[2]);
+	FLASH_SF_ACCESS_t sf_access;
+	FLASH_FLASH_ACCESS_START_t access_start;
+	FLASH_SF_EXT_ACCESS_t sf_ext_access;
+
+	sf_access.wrd = 0;
+	access_start.wrd = 0;
+	sf_ext_access.wrd = 0;
+
+	/* Flush cache to flash chip
+	 * Opcode -> 24bits offset addr
+	 */
+	sf_access.bf.sflashAcCode = GET_UP8BITS(SF_AC_OPCODE_EXTEND);
+	write_flash_ctrl_reg(FLASH_SF_ACCESS, sf_access.wrd);
+
+	/* Use command in extend_acc register */
+	sf_ext_access.bf.sflashDirRdCmdEn = 1;
+	sf_ext_access.bf.sflashOpCode = SPINAND_CMD_PROG_EXC;
+	/* 0 dummy bits */
+	sf_ext_access.bf.sflashDummyCount = -1;/* (cmd_cfg->dummy_bytes * 8) - 1; */
+	/* 3 byte address */
+	sf_ext_access.bf.sflashAddrCount = 2;/* cmd_cfg->addr_bytes - 1; */
+	/* zero data byte */
+	sf_ext_access.bf.sflashDataCount = -1; /* cmd_cfg->data_bits - 1; */
+	write_flash_ctrl_reg(FLASH_SF_EXT_ACCESS, sf_ext_access.wrd);
+
+	/* Fill address */
+	write_flash_ctrl_reg(FLASH_SF_ADDRESS, offset);
+
+	write_flash_ctrl_reg(FLASH_FLASH_ACCESS_START, SF_START_BIT_ENABLE);
+
+	/* Wait command ready */
+	if (wait_flash_cmd_rdy(SFLASH_CMD_TIMEOUT) != 0) {
+		printk("%s fail!\n", __func__);
+		return -1;
+	}
+
+	return 0;
+}
+
+static int ca_spinand_erase_block(struct spi_nand_cmd *cmd)
+{
+	u32 block_id = (u32)(cmd->addr[0] << 16) | (u32)(cmd->addr[1] << 8)
+		| (u32)(cmd->addr[2]);
+	FLASH_SF_ACCESS_t sf_access;
+
+	sf_access.wrd = 0;
+
+	/* Write enable
+	 * Opcode only protocol
+	 */
+	sf_access.bf.sflashOpCode = SPINAND_CMD_WR_ENABLE;
+	sf_access.bf.sflashAcCode = GET_UP8BITS(SF_AC_OPCODE);
+	write_flash_ctrl_reg(FLASH_SF_ACCESS, sf_access.wrd);
+	write_flash_ctrl_reg(FLASH_FLASH_ACCESS_START, SF_START_BIT_ENABLE);
+
+	/* Wait command ready */
+	if (wait_flash_cmd_rdy(SFLASH_CMD_TIMEOUT) != 0)
+		printk("%s: command timeout!\n", __func__);
+
+
+	/* Erase block
+	 * Opcode -> 24bits Addr
+	 */
+	sf_access.bf.sflashOpCode = SPINAND_CMD_BLK_ERASE;
+	sf_access.bf.sflashAcCode = GET_UP8BITS(SF_AC_OPCODE_3_ADDR);
+	write_flash_ctrl_reg(FLASH_SF_ACCESS, sf_access.wrd);
+	write_flash_ctrl_reg(FLASH_SF_ADDRESS, block_id);
+	write_flash_ctrl_reg(FLASH_FLASH_ACCESS_START, SF_START_BIT_ENABLE);
+
+	/* Wait command ready */
+	if (wait_flash_cmd_rdy(SFLASH_CMD_TIMEOUT) != 0) {
+		printk("%s fail!\n", __func__);
+		return -1;
+	}
+
+	/* elapse 1ms before issuing any other command */
+	udelay(10);
+
+	if (wait_till_ready()) {
+		printk("%s wait timeout %d!\n", __func__, block_id);
+		return -1;
+	}
+
+	return 0;
+}
+
+/*
+ * ca_spinand_cmd_fn - to process a command to send to the SPI-NAND
+ * by cortina SPI NAND controller
+ * @chip: SPI-NAND device structure
+ * @cmd: command structure
+ * Description:
+ *   Set up the command buffer to send to the SPI controller.
+ *   The command buffer has to initialized to 0.
+ */
+int ca_spinand_cmd_fn(struct spi_nand_chip *chip,
+				struct spi_nand_cmd *cmd)
+{
+	int ret = 0;
+
+	switch (cmd->cmd) {
+	case SPINAND_CMD_RESET:
+		ret = ca_spinand_reset(cmd);
+		break;
+	case SPINAND_CMD_GET_FEATURE:
+		ret = ca_spinand_get_feature_reg(cmd);
+		break;
+	case SPINAND_CMD_SET_FEATURE:
+		ret = ca_spinand_set_feature_reg(cmd);
+		break;
+	case SPINAND_CMD_PAGE_READ:
+		ret = ca_spinand_read_page_to_cache(cmd);
+		break;
+	case SPINAND_CMD_READ_PAGE_CACHE_RDM:
+		/* Todo */
+		spi_nand_debug("%s()..READ_PAGE_CACHE_RDM not implement yet.\n",
+			__func__);
+		break;
+	case SPINAND_CMD_READ_PAGE_CACHE_LAST:
+		/* Todo */
+		spi_nand_debug("%s()...READ_PAGE_CACHE_LAST not implement yet.\n",
+			__func__);
+		break;
+	case SPINAND_CMD_READ_FROM_CACHE:
+	case SPINAND_CMD_READ_FROM_CACHE_FAST:
+		ret = ca_spinand_read_cache_x1(cmd);
+		break;
+	case SPINAND_CMD_READ_FROM_CACHE_X2:
+	case SPINAND_CMD_READ_FROM_CACHE_DUAL_IO:
+		ret = ca_spinand_read_cache_x2(cmd);
+		break;
+	case SPINAND_CMD_READ_FROM_CACHE_X4:
+	case SPINAND_CMD_READ_FROM_CACHE_QUAD_IO:
+		ret = ca_spinand_read_cache_x4(cmd);
+		break;
+	case SPINAND_CMD_BLK_ERASE:
+		ret = ca_spinand_erase_block(cmd);
+		break;
+	case SPINAND_CMD_PROG_EXC:
+		ret = ca_spinand_program_execute(cmd);
+		break;
+	case SPINAND_CMD_PROG_LOAD:
+		ret = ca_spinand_write_cache_x1(cmd);
+		break;
+	case SPINAND_CMD_PROG_LOAD_RDM_DATA:
+		/* Todo */
+		spi_nand_debug("%s()...PROG_LOAD_RDM_DATA not implement yet.\n",
+			__func__);
+		break;
+	case SPINAND_CMD_PROG_LOAD_X4:
+		ret = ca_spinand_write_cache_x4(cmd);
+		break;
+	case SPINAND_CMD_PROG_LOAD_RDM_DATA_X4:
+		/* Todo */
+		spi_nand_debug("%s()...PROG_LOAD_RDM_DATA_X4 not implement yet.\n",
+			__func__);
+		break;
+	case SPINAND_CMD_READ_ID:
+		ret = ca_spinand_read_id(cmd);
+		break;
+	case SPINAND_CMD_WR_DISABLE:
+		/* Todo */
+		break;
+	case SPINAND_CMD_WR_ENABLE:
+		ret = ca_spinand_write_enable(cmd);
+		break;
+	case SPINAND_CMD_END:
+	default:
+		break;
+	}
+
+    return ret;
+}
+
+struct spi_nand_chip *spi_nand_flash_probe(unsigned int bus, unsigned int cs,
+								  unsigned int max_hz, unsigned int spi_mode)
+{
+	struct spi_slave *slave;
+	struct spi_nand_chip *chip;
+	u32 addr;
+	int ret = 0;
+
+	/* Set FLASH_TYPE as serial flash, flash_pin = 1 */
+	write_flash_ctrl_reg(FLASH_TYPE, 0x8000);
+
+#ifdef CONFIG_CA82XX
+	GLOBAL_PIN_MUX_t pin_mux;
+	/* Enable 4 bit IO  */
+	pin_mux.wrd = readl(KSEG1_ATU_XLAT(GLOBAL_PIN_MUX));
+	pin_mux.bf.iomux_sflash4_enable = 1;
+	writel(pin_mux.wrd, KSEG1_ATU_XLAT(GLOBAL_PIN_MUX));
+#endif
+
+	slave = malloc(sizeof(struct spi_slave));
+	if (!slave) {
+		debug("NAND Flash slave: Failed to allocate memory\n");
+		return NULL;
+	}
+
+	/* Minimize flash timing */
+	write_flash_ctrl_reg(FLASH_SF_TIMING, 0x07010101);
+
+	/*
+	 * [SPI RX operation modes]:
+	 *		SPI_OPM_RX_QOF  - SPINAND_CMD_READ_FROM_CACHE_QUAD_IO
+	 *		SPI_OPM_RX_DOUT - SPINAND_CMD_READ_FROM_CACHE_DUAL_IO
+	 *			else        - SPINAND_CMD_READ_FROM_CACHE_FAST (defualt)
+	 * [SPI TX operation modes]:
+	 *		SPI_OPM_TX_QPP  - SPINAND_CMD_PROG_LOAD_X4
+	 *			else        - SPINAND_CMD_PROG_LOAD (defualt)
+	 */
+	slave->op_mode_rx = SPI_OPM_RX_QOF;
+	slave->op_mode_tx = SPI_OPM_TX_QPP;
+
+	ret = spi_nand_init(slave, &chip);
+	if (ret) {
+		printf("SPI NAND init failed\n");
+		return ret;
+	}
+
+	spi_nand_debug("%s\n",chip->name);
+	spi_nand_debug("spinand_oob_size:0x%x\n",chip->oob_size);
+	spi_nand_debug("spinand_page_size:0x%x\n",chip->page_size);
+	spi_nand_debug("spinand_blk_size:0x%x\n",chip->block_size);
+	spi_nand_debug("spinand_size:0x%x\n",chip->size);
+
+	return chip;
+}
+
+void spi_nand_flash_free(struct spi_nand_chip *chip)
+{
+	free(chip->spi);
+	free(chip);
+}
diff --git a/drivers/mtd/spi-nand/spi-nand-base.c b/drivers/mtd/spi-nand/spi-nand-base.c
old mode 100644
new mode 100755
index 2982d9e..d5a69ad
--- a/drivers/mtd/spi-nand/spi-nand-base.c
+++ b/drivers/mtd/spi-nand/spi-nand-base.c
@@ -21,6 +21,9 @@
 #include <spi.h>
 
 extern int spi_nand_issue_cmd(struct spi_nand_chip *chip, struct spi_nand_cmd *cmd);
+#ifdef CONFIG_MTD_CORTINA_SPI_NAND
+extern int ca_spinand_cmd_fn(struct spi_nand_chip * chip,struct spi_nand_cmd * cmd);
+#endif
 static int spi_nand_erase(struct spi_nand_chip *chip, uint64_t addr, uint64_t len);
 
 static struct spi_nand_flash spi_nand_table[] = {
@@ -1005,6 +1008,9 @@ again:
 static inline bool is_read_page_fast_benefit(struct spi_nand_chip *chip,
 			loff_t from, size_t len)
 {
+	return false;
+	/* Alway return false!!! */
+
 	if (len < chip->page_size << 2)
 		return false;
 	if (from >> chip->lun_shift == (from + len) >> chip->lun_shift)
@@ -1793,7 +1799,7 @@ static void spi_nand_set_rd_wr_op(struct spi_nand_chip *chip)
  * @spi: spi device structure
  * @chip_ptr: pointer point to spi nand device structure pointer
  */
-static int spi_nand_init(struct spi_slave *spi, struct spi_nand_chip **chip_ptr)
+int spi_nand_init(struct spi_slave *spi, struct spi_nand_chip **chip_ptr)
 {
 	u8 id[SPINAND_MAX_ID_LEN] = {0};
 	struct spi_nand_chip *chip = NULL;
@@ -1805,6 +1811,10 @@ static int spi_nand_init(struct spi_slave *spi, struct spi_nand_chip **chip_ptr)
 	memset(chip, 0, sizeof(struct spi_nand_chip));
 	chip->spi = spi;
 
+#ifdef CONFIG_MTD_CORTINA_SPI_NAND
+	chip->command_fn = ca_spinand_cmd_fn;
+#endif
+
 	spi_nand_set_rd_wr_op(chip);
 	spi_nand_reset(chip);
 	spi_nand_read_id(chip, id);
diff --git a/drivers/mtd/spi-nand/spi-nand-cmd.c b/drivers/mtd/spi-nand/spi-nand-cmd.c
old mode 100644
new mode 100755
index 9840a46..aaec9df
--- a/drivers/mtd/spi-nand/spi-nand-cmd.c
+++ b/drivers/mtd/spi-nand/spi-nand-cmd.c
@@ -72,7 +72,7 @@ static struct spi_nand_cmd_cfg *spi_nand_lookup_cmd_cfg_table(u8 opcode,
 	BUG();
 }
 
-
+#ifdef CONFIG_DM_SPI
 static int spi_nand_xfer(struct spi_slave *slave, unsigned int bitlen, u8 bits,
 			const void *dout, void *din, unsigned long flags)
 {
@@ -83,6 +83,7 @@ static int spi_nand_xfer(struct spi_slave *slave, unsigned int bitlen, u8 bits,
 
 	return spi_xfer(slave, bitlen, dout, din, flags);
 }
+#endif
 
 /*
  * spi_nand_issue_cmd - to process a command to send to the SPI-NAND
@@ -94,6 +95,9 @@ static int spi_nand_xfer(struct spi_slave *slave, unsigned int bitlen, u8 bits,
  */
 int spi_nand_issue_cmd(struct spi_nand_chip *chip, struct spi_nand_cmd *cmd)
 {
+#ifdef CONFIG_MTD_CORTINA_SPI_NAND
+	return chip->command_fn(chip, cmd);
+#else
 	struct spi_nand_cmd_cfg *cmd_cfg = NULL;
 	struct spi_slave *spi = chip->spi;
 	int flags = SPI_XFER_BEGIN;
@@ -128,4 +132,6 @@ int spi_nand_issue_cmd(struct spi_nand_chip *chip, struct spi_nand_cmd *cmd)
 	}
 
 	return 0;
+#endif
+
 }
diff --git a/include/configs/saturn-asic.h b/include/configs/saturn-asic.h
index 943aad4..c888177 100755
--- a/include/configs/saturn-asic.h
+++ b/include/configs/saturn-asic.h
@@ -84,11 +84,11 @@
 
 #define CONFIG_EXTRA_ENV_SETTINGS	\
 					"dtb_addr=0x85000000\0"		\
-					"dtb_size=0x10000\0"		/* 64K */\
+					"dtb_size=0x100000\0"		/* 1024K */\
 					"kernel_addr=0x85100000\0"	\
-					"kernel_size=0xd00000\0"	/* 14M */\
+					"kernel_size=0x600000\0"	/* 6M */\
 					"rootfs_addr=0x86000000\0"	\
-					"rootfs_size=0x600000\0"    /* 6M */	\
+					"rootfs_size=0x6000000\0"    /* 96M */	\
                     "dtb_load_addr=0x87000000\0" \
                     "kernel_load_addr=0x87100000\0" \
                     "w_fip=sf erase 0 0x50000; sf write 0x88000000 0 0x50000; \0"\
@@ -98,11 +98,20 @@
                     "l_kernel=sf read ${kernel_load_addr} 0x600000 ${kernel_size} \0" \
                     "w_rootfs=sf erase 0x70000 ${rootfs_size}; sf write ${rootfs_addr} 0x70000 ${rootfs_size}; \0"\
                     "l_rootfs=sf read ${rootfs_addr} 0x70000 ${rootfs_size};\0"\
+                    "spinand_w_fip=spi_nand erase 0 0x400000; spi_nand write 0x88000000 0 0x400000; \0"\
+                    "spinand_w_dtb=spi_nand erase 0x500000 ${dtb_size}; spi_nand write ${dtb_addr} 0x500000 ${dtb_size}; \0"\
+                    "spinand_l_dtb=spi_nand read ${dtb_load_addr} 0x500000 ${dtb_size};\0"\
+                    "spinand_w_kernel=spi_nand erase 0x600000 ${kernel_size}; spi_nand write ${kernel_addr} 0x600000 ${kernel_size};\0"\
+                    "spinand_l_kernel=spi_nand read ${kernel_load_addr} 0x600000 ${kernel_size} \0" \
+                    "spinand_w_rootfs=spi_nand erase 0xC00000 ${rootfs_size}; spi_nand write ${rootfs_addr} 0xC00000 ${rootfs_size}; \0"\
+                    "spinand_l_rootfs=spi_nand read ${rootfs_addr} 0xC00000 ${rootfs_size};\0"\
                     "m_titan=bootm ${kernel_addr} - ${dtb_addr}\0" \
                     "f_titan=run l_dtb; run l_kernel; bootm ${kernel_load_addr} - ${dtb_load_addr}\0" \
+                    "spinand_f_titan=run spinand_l_dtb; run spinand_l_kernel; bootm ${kernel_load_addr} - ${dtb_load_addr}\0" \
                     "tftp_kernel=tftpboot 0x85100000 uImage;tftpboot 0x85000000 uImage-saturn_sfu.dtb;tftpboot 0x86000000 major-image-saturn-sfu-eng.cpio.xz\0" \
                     "boot_kernel=fdt addr 0x85000000; setenv bootargs rd_start=0x86000000 rd_size=0x${filesize} root=/dev/ram console=ttyS0,115200;fdt set /chosen bootargs \"$bootargs\" ;bootm 0x85100000 - 0x85000000\0" \
-                    "upd=tftp 0x85000000 gpt-image;sf erase 0 0x300000;sf write 0x85000000 0 0x300000;\0"
+                    "upd=tftp 0x85000000 gpt-image;sf erase 0 0x300000;sf write 0x85000000 0 0x300000;\0" \
+                    "spinand_upd=tftp 0x85000000 gpt-image;spi_nand erase 0 0x400000;spi_nand write 0x85000000 0 0x400000;\0"
 
 #define CONFIG_BOOTCOMMAND		"run f_titan"
 //#define CONFIG_BOOTARGS			"earlycon=serial,0xb2224148 console=ttyS0,115200 root=/dev/ram0 mem=256M"
@@ -229,7 +238,7 @@
 	#define CONFIG_CMD_SF_TEST
 	#define CONFIG_SYS_NO_FLASH
 
-	#undef CONFIG_ENV_IS_IN_FLASH
+	#undef CONFIG_ENV_IS_IN_SPI_FLASH
 	#define CONFIG_ENV_IS_IN_SPI_FLASH
 
 	#define PHYS_FLASH_1		(CONFIG_SYS_FLASH_BASE)
@@ -256,4 +265,29 @@
 #endif
 
 #endif /* CONFIG_MTD_CORTINA_SERIAL_NOR */
+
+#if defined(CONFIG_MTD_CORTINA_SPI_NAND)
+	#undef CONFIG_BOOTCOMMAND
+	#define CONFIG_BOOTCOMMAND "spi_nand read $kernel_addr_r 0x200000 0x900000;spi_nand read $fdt_addr_r 0x100000 0x10000;booti $kernel_addr_r - $fdt_addr_r"
+	#define CONFIG_CMD_SPI_NAND
+	#define CONFIG_CMD_SPI_NAND_TEST
+	#define CONFIG_SYS_NO_FLASH
+
+	#undef CONFIG_ENV_IS_IN_SPI_NAND
+	#define CONFIG_ENV_IS_IN_SPI_NAND
+
+	#define PHYS_FLASH_1		(CONFIG_SYS_FLASH_BASE)
+
+	#define CONFIG_ENV_SPI_MAX_HZ	1000000
+	#define CONFIG_ENV_SPI_MODE		SPI_MODE_3
+	#define CONFIG_ENV_SPI_BUS		0
+	#define CONFIG_ENV_SPI_CS		1
+	
+	#define CONFIG_ENV_OFFSET		(0x480000)
+	#define CONFIG_ENV_SIZE			(0x20000)
+	#define CONFIG_ENV_RANGE		(0x80000)
+	#define CONFIG_ENV_SECT_SIZE		(CONFIG_ENV_SIZE)
+	#define CONFIG_ENV_ADDR			(PHYS_FLASH_1 + CONFIG_ENV_OFFSET)
+#endif /* CONFIG_MTD_CORTINA_SPI_NAND */
+
 #endif /* __SATURN_ASIC_H */
diff --git a/include/spi-nand.h b/include/spi-nand.h
old mode 100644
new mode 100755
index c525e6f..be80f6d
--- a/include/spi-nand.h
+++ b/include/spi-nand.h
@@ -237,6 +237,13 @@ struct spi_nand_chip {
 	u8		lun;
 	struct nand_ecclayout *ecclayout;
 	struct spi_nand_onfi_params	 onfi_params;
+
+#ifdef CONFIG_MTD_CORTINA_SPI_NAND
+	int (*command_fn)(struct spi_nand_chip *this,
+		struct spi_nand_cmd *cmd);
+
+#endif
+
 };
 
 struct spi_nand_flash {
@@ -283,6 +290,7 @@ enum {
 #define SPINAND_NEED_DIE_SELECT	(1 << 1)
 
 #define SPINAND_MFR_MICRON		0x2C
+#define SPINAND_MFR_GIGADEVICE	0xC8
 #define SPINAND_MAX_ID_LEN		2
 
 #ifdef DEBUG
@@ -303,6 +311,11 @@ int spi_nand_cmd_write_ops(struct spi_nand_chip *chip, u32 offset,
 int spi_nand_cmd_erase_ops(struct spi_nand_chip *chip, u32 offset, size_t len, bool spread);
 struct spi_nand_chip *spi_nand_flash_probe(unsigned int busnum, unsigned int cs,
 		unsigned int max_hz, unsigned int spi_mode);
+
+#ifdef CONFIG_MTD_CORTINA_SPI_NAND
+int spi_nand_init(struct spi_slave *spi, struct spi_nand_chip **chip_ptr);
+#endif
+
 void spi_nand_flash_free(struct spi_nand_chip *chip);
 void spi_nand_release(struct spi_nand_chip *chip);
 #endif
-- 
1.8.3.1

